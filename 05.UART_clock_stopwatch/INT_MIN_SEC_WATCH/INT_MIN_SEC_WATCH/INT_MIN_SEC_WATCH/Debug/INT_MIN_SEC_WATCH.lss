
INT_MIN_SEC_WATCH.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000094  00800100  00000f4a  00000fde  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f4a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000e5  00800194  00800194  00001072  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001072  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000010a4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001e8  00000000  00000000  000010e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000021d5  00000000  00000000  000012cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000010b5  00000000  00000000  000034a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001166  00000000  00000000  00004556  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000003c0  00000000  00000000  000056bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000861  00000000  00000000  00005a7c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000006b3  00000000  00000000  000062dd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000168  00000000  00000000  00006990  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	53 c0       	rjmp	.+166    	; 0xa8 <__ctors_end>
   2:	00 00       	nop
   4:	6e c0       	rjmp	.+220    	; 0xe2 <__bad_interrupt>
   6:	00 00       	nop
   8:	6c c0       	rjmp	.+216    	; 0xe2 <__bad_interrupt>
   a:	00 00       	nop
   c:	6a c0       	rjmp	.+212    	; 0xe2 <__bad_interrupt>
   e:	00 00       	nop
  10:	68 c0       	rjmp	.+208    	; 0xe2 <__bad_interrupt>
  12:	00 00       	nop
  14:	66 c0       	rjmp	.+204    	; 0xe2 <__bad_interrupt>
  16:	00 00       	nop
  18:	64 c0       	rjmp	.+200    	; 0xe2 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	62 c0       	rjmp	.+196    	; 0xe2 <__bad_interrupt>
  1e:	00 00       	nop
  20:	60 c0       	rjmp	.+192    	; 0xe2 <__bad_interrupt>
  22:	00 00       	nop
  24:	5e c0       	rjmp	.+188    	; 0xe2 <__bad_interrupt>
  26:	00 00       	nop
  28:	5c c0       	rjmp	.+184    	; 0xe2 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	5a c0       	rjmp	.+180    	; 0xe2 <__bad_interrupt>
  2e:	00 00       	nop
  30:	58 c0       	rjmp	.+176    	; 0xe2 <__bad_interrupt>
  32:	00 00       	nop
  34:	56 c0       	rjmp	.+172    	; 0xe2 <__bad_interrupt>
  36:	00 00       	nop
  38:	54 c0       	rjmp	.+168    	; 0xe2 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	52 c0       	rjmp	.+164    	; 0xe2 <__bad_interrupt>
  3e:	00 00       	nop
  40:	e0 c2       	rjmp	.+1472   	; 0x602 <__vector_16>
  42:	00 00       	nop
  44:	4e c0       	rjmp	.+156    	; 0xe2 <__bad_interrupt>
  46:	00 00       	nop
  48:	13 c5       	rjmp	.+2598   	; 0xa70 <__vector_18>
  4a:	00 00       	nop
  4c:	4a c0       	rjmp	.+148    	; 0xe2 <__bad_interrupt>
  4e:	00 00       	nop
  50:	48 c0       	rjmp	.+144    	; 0xe2 <__bad_interrupt>
  52:	00 00       	nop
  54:	46 c0       	rjmp	.+140    	; 0xe2 <__bad_interrupt>
  56:	00 00       	nop
  58:	44 c0       	rjmp	.+136    	; 0xe2 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	42 c0       	rjmp	.+132    	; 0xe2 <__bad_interrupt>
  5e:	00 00       	nop
  60:	40 c0       	rjmp	.+128    	; 0xe2 <__bad_interrupt>
  62:	00 00       	nop
  64:	3e c0       	rjmp	.+124    	; 0xe2 <__bad_interrupt>
  66:	00 00       	nop
  68:	3c c0       	rjmp	.+120    	; 0xe2 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	3a c0       	rjmp	.+116    	; 0xe2 <__bad_interrupt>
  6e:	00 00       	nop
  70:	38 c0       	rjmp	.+112    	; 0xe2 <__bad_interrupt>
  72:	00 00       	nop
  74:	36 c0       	rjmp	.+108    	; 0xe2 <__bad_interrupt>
  76:	00 00       	nop
  78:	34 c0       	rjmp	.+104    	; 0xe2 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	32 c0       	rjmp	.+100    	; 0xe2 <__bad_interrupt>
  7e:	00 00       	nop
  80:	30 c0       	rjmp	.+96     	; 0xe2 <__bad_interrupt>
  82:	00 00       	nop
  84:	2e c0       	rjmp	.+92     	; 0xe2 <__bad_interrupt>
  86:	00 00       	nop
  88:	2c c0       	rjmp	.+88     	; 0xe2 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	2b 06       	cpc	r2, r27
  8e:	2d 06       	cpc	r2, r29
  90:	2f 06       	cpc	r2, r31
  92:	31 06       	cpc	r3, r17
  94:	33 06       	cpc	r3, r19
  96:	35 06       	cpc	r3, r21
  98:	37 06       	cpc	r3, r23
  9a:	1d 07       	cpc	r17, r29
  9c:	1f 07       	cpc	r17, r31
  9e:	21 07       	cpc	r18, r17
  a0:	23 07       	cpc	r18, r19
  a2:	25 07       	cpc	r18, r21
  a4:	27 07       	cpc	r18, r23
  a6:	29 07       	cpc	r18, r25

000000a8 <__ctors_end>:
  a8:	11 24       	eor	r1, r1
  aa:	1f be       	out	0x3f, r1	; 63
  ac:	cf ef       	ldi	r28, 0xFF	; 255
  ae:	d0 e1       	ldi	r29, 0x10	; 16
  b0:	de bf       	out	0x3e, r29	; 62
  b2:	cd bf       	out	0x3d, r28	; 61

000000b4 <__do_copy_data>:
  b4:	11 e0       	ldi	r17, 0x01	; 1
  b6:	a0 e0       	ldi	r26, 0x00	; 0
  b8:	b1 e0       	ldi	r27, 0x01	; 1
  ba:	ea e4       	ldi	r30, 0x4A	; 74
  bc:	ff e0       	ldi	r31, 0x0F	; 15
  be:	00 e0       	ldi	r16, 0x00	; 0
  c0:	0b bf       	out	0x3b, r16	; 59
  c2:	02 c0       	rjmp	.+4      	; 0xc8 <__do_copy_data+0x14>
  c4:	07 90       	elpm	r0, Z+
  c6:	0d 92       	st	X+, r0
  c8:	a4 39       	cpi	r26, 0x94	; 148
  ca:	b1 07       	cpc	r27, r17
  cc:	d9 f7       	brne	.-10     	; 0xc4 <__do_copy_data+0x10>

000000ce <__do_clear_bss>:
  ce:	22 e0       	ldi	r18, 0x02	; 2
  d0:	a4 e9       	ldi	r26, 0x94	; 148
  d2:	b1 e0       	ldi	r27, 0x01	; 1
  d4:	01 c0       	rjmp	.+2      	; 0xd8 <.do_clear_bss_start>

000000d6 <.do_clear_bss_loop>:
  d6:	1d 92       	st	X+, r1

000000d8 <.do_clear_bss_start>:
  d8:	a9 37       	cpi	r26, 0x79	; 121
  da:	b2 07       	cpc	r27, r18
  dc:	e1 f7       	brne	.-8      	; 0xd6 <.do_clear_bss_loop>
  de:	c4 d3       	rcall	.+1928   	; 0x868 <main>
  e0:	32 c7       	rjmp	.+3684   	; 0xf46 <_exit>

000000e2 <__bad_interrupt>:
  e2:	8e cf       	rjmp	.-228    	; 0x0 <__vectors>

000000e4 <init_BUTTON>:
int get_BUTTON3();
void init_BUTTON();

void init_BUTTON()
{
	BUTTON_DDR &= ~((1 << BUTTON1) | (1 << BUTTON2) | (1 << BUTTON3) | (1 << BUTTON4));
  e4:	81 b3       	in	r24, 0x11	; 17
  e6:	8f 70       	andi	r24, 0x0F	; 15
  e8:	81 bb       	out	0x11, r24	; 17
  ea:	08 95       	ret

000000ec <get_BUTTON1>:
{
	 
	static uint8_t prev_state = 0; // 버튼의 상태 0: OFF , 1 : ON / 함수 실행 후에도 값이 변하지 않음
	uint8_t current_state; // unsigned char와 동일함 == unsigned int 8bit  // unsigned char current_state 
	
	current_state = BUTTON_PIN & (1 << BUTTON1); // Button1의 값을 읽는다. , 읽었을 때 (0x10)
  ec:	80 b3       	in	r24, 0x10	; 16
  ee:	80 71       	andi	r24, 0x10	; 16
	
	if(prev_state == 0 && current_state != 0) // 버튼이 처음 눌려진 상태 	
  f0:	90 91 96 01 	lds	r25, 0x0196	; 0x800196 <prev_state.1736>
  f4:	91 11       	cpse	r25, r1
  f6:	11 c0       	rjmp	.+34     	; 0x11a <get_BUTTON1+0x2e>
  f8:	88 23       	and	r24, r24
  fa:	79 f0       	breq	.+30     	; 0x11a <get_BUTTON1+0x2e>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  fc:	2f ef       	ldi	r18, 0xFF	; 255
  fe:	8d ee       	ldi	r24, 0xED	; 237
 100:	92 e0       	ldi	r25, 0x02	; 2
 102:	21 50       	subi	r18, 0x01	; 1
 104:	80 40       	sbci	r24, 0x00	; 0
 106:	90 40       	sbci	r25, 0x00	; 0
 108:	e1 f7       	brne	.-8      	; 0x102 <get_BUTTON1+0x16>
 10a:	00 c0       	rjmp	.+0      	; 0x10c <get_BUTTON1+0x20>
 10c:	00 00       	nop
	{
		_delay_ms(60);	// 노이즈가 지나가기를 기다림
		prev_state = 1; // 처음 눌러진 상태가 아니다. 
 10e:	81 e0       	ldi	r24, 0x01	; 1
 110:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <prev_state.1736>
		return 0;		// 아직은 진짜로 눌러진 상태가 아니라 0을 return 
 114:	80 e0       	ldi	r24, 0x00	; 0
 116:	90 e0       	ldi	r25, 0x00	; 0
 118:	08 95       	ret
		
	}
	else if(prev_state == 1 && current_state == 0) // 버튼이 눌렸다 떼어진 상태 
 11a:	91 30       	cpi	r25, 0x01	; 1
 11c:	81 f4       	brne	.+32     	; 0x13e <get_BUTTON1+0x52>
 11e:	81 11       	cpse	r24, r1
 120:	11 c0       	rjmp	.+34     	; 0x144 <get_BUTTON1+0x58>
	{
		prev_state = 0; 
 122:	10 92 96 01 	sts	0x0196, r1	; 0x800196 <prev_state.1736>
 126:	2f ef       	ldi	r18, 0xFF	; 255
 128:	86 e7       	ldi	r24, 0x76	; 118
 12a:	91 e0       	ldi	r25, 0x01	; 1
 12c:	21 50       	subi	r18, 0x01	; 1
 12e:	80 40       	sbci	r24, 0x00	; 0
 130:	90 40       	sbci	r25, 0x00	; 0
 132:	e1 f7       	brne	.-8      	; 0x12c <get_BUTTON1+0x40>
 134:	00 c0       	rjmp	.+0      	; 0x136 <get_BUTTON1+0x4a>
 136:	00 00       	nop
		_delay_ms(30);	// 노이즈가 지나가기를 기다림
		return 1; // 완전히 눌렸다 떼어진 상태로 인정
 138:	81 e0       	ldi	r24, 0x01	; 1
 13a:	90 e0       	ldi	r25, 0x00	; 0
 13c:	08 95       	ret
	}
	return 0; // 아직 완전히 sw 을 눌렀다 떼어지지 않은 상태
 13e:	80 e0       	ldi	r24, 0x00	; 0
 140:	90 e0       	ldi	r25, 0x00	; 0
 142:	08 95       	ret
 144:	80 e0       	ldi	r24, 0x00	; 0
 146:	90 e0       	ldi	r25, 0x00	; 0
}
 148:	08 95       	ret

0000014a <get_BUTTON2>:
{
	 
	static uint8_t prev_state = 0;
	uint8_t current_state; // unsigned char와 동일함 == unsigned int 8bit  // unsigned char current_state
	
	current_state = BUTTON_PIN & (1 << BUTTON2); // Button1의 값을 읽는다. , 읽었을 때 (0x10)
 14a:	80 b3       	in	r24, 0x10	; 16
 14c:	80 72       	andi	r24, 0x20	; 32
	
	if(prev_state == 0 && current_state != 0) // 버튼이 처음 눌려진 상태
 14e:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <prev_state.1740>
 152:	91 11       	cpse	r25, r1
 154:	11 c0       	rjmp	.+34     	; 0x178 <get_BUTTON2+0x2e>
 156:	88 23       	and	r24, r24
 158:	79 f0       	breq	.+30     	; 0x178 <get_BUTTON2+0x2e>
 15a:	2f ef       	ldi	r18, 0xFF	; 255
 15c:	8d ee       	ldi	r24, 0xED	; 237
 15e:	92 e0       	ldi	r25, 0x02	; 2
 160:	21 50       	subi	r18, 0x01	; 1
 162:	80 40       	sbci	r24, 0x00	; 0
 164:	90 40       	sbci	r25, 0x00	; 0
 166:	e1 f7       	brne	.-8      	; 0x160 <get_BUTTON2+0x16>
 168:	00 c0       	rjmp	.+0      	; 0x16a <get_BUTTON2+0x20>
 16a:	00 00       	nop
	{
		_delay_ms(60);	// 노이즈가 지나가기를 기다림
		prev_state = 1; // 처음 눌러진 상태가 아니다.
 16c:	81 e0       	ldi	r24, 0x01	; 1
 16e:	80 93 95 01 	sts	0x0195, r24	; 0x800195 <prev_state.1740>
		return 0;		// 아직은 진짜로 눌러진 상태가 아니라 0을 return
 172:	80 e0       	ldi	r24, 0x00	; 0
 174:	90 e0       	ldi	r25, 0x00	; 0
 176:	08 95       	ret
		
	}
	else if(prev_state == 1 && current_state == 0) // 버튼이 눌렸다 떼어진 상태
 178:	91 30       	cpi	r25, 0x01	; 1
 17a:	81 f4       	brne	.+32     	; 0x19c <get_BUTTON2+0x52>
 17c:	81 11       	cpse	r24, r1
 17e:	11 c0       	rjmp	.+34     	; 0x1a2 <get_BUTTON2+0x58>
	{
		prev_state = 0;
 180:	10 92 95 01 	sts	0x0195, r1	; 0x800195 <prev_state.1740>
 184:	2f ef       	ldi	r18, 0xFF	; 255
 186:	86 e7       	ldi	r24, 0x76	; 118
 188:	91 e0       	ldi	r25, 0x01	; 1
 18a:	21 50       	subi	r18, 0x01	; 1
 18c:	80 40       	sbci	r24, 0x00	; 0
 18e:	90 40       	sbci	r25, 0x00	; 0
 190:	e1 f7       	brne	.-8      	; 0x18a <get_BUTTON2+0x40>
 192:	00 c0       	rjmp	.+0      	; 0x194 <get_BUTTON2+0x4a>
 194:	00 00       	nop
		_delay_ms(30);	// 노이즈가 지나가기를 기다림
		return 1; // 완전히 눌렸다 떼어진 상태로 인정
 196:	81 e0       	ldi	r24, 0x01	; 1
 198:	90 e0       	ldi	r25, 0x00	; 0
 19a:	08 95       	ret
	}
	return 0; // 아직 완전히 sw 을 눌렀다 떼어지지 않은 상태
 19c:	80 e0       	ldi	r24, 0x00	; 0
 19e:	90 e0       	ldi	r25, 0x00	; 0
 1a0:	08 95       	ret
 1a2:	80 e0       	ldi	r24, 0x00	; 0
 1a4:	90 e0       	ldi	r25, 0x00	; 0
}
 1a6:	08 95       	ret

000001a8 <get_BUTTON3>:
{
	
	static uint8_t prev_state = 0;
	uint8_t current_state; // unsigned char와 동일함 == unsigned int 8bit  // unsigned char current_state
	
	current_state = BUTTON_PIN & (1 << BUTTON3); // Button1의 값을 읽는다. , 읽었을 때 (0x10)
 1a8:	80 b3       	in	r24, 0x10	; 16
 1aa:	80 74       	andi	r24, 0x40	; 64
	
	if(prev_state == 0 && current_state != 0) // 버튼이 처음 눌려진 상태
 1ac:	90 91 94 01 	lds	r25, 0x0194	; 0x800194 <__data_end>
 1b0:	91 11       	cpse	r25, r1
 1b2:	11 c0       	rjmp	.+34     	; 0x1d6 <get_BUTTON3+0x2e>
 1b4:	88 23       	and	r24, r24
 1b6:	79 f0       	breq	.+30     	; 0x1d6 <get_BUTTON3+0x2e>
 1b8:	2f ef       	ldi	r18, 0xFF	; 255
 1ba:	8d ee       	ldi	r24, 0xED	; 237
 1bc:	92 e0       	ldi	r25, 0x02	; 2
 1be:	21 50       	subi	r18, 0x01	; 1
 1c0:	80 40       	sbci	r24, 0x00	; 0
 1c2:	90 40       	sbci	r25, 0x00	; 0
 1c4:	e1 f7       	brne	.-8      	; 0x1be <get_BUTTON3+0x16>
 1c6:	00 c0       	rjmp	.+0      	; 0x1c8 <get_BUTTON3+0x20>
 1c8:	00 00       	nop
	{
		_delay_ms(60);	// 노이즈가 지나가기를 기다림
		prev_state = 1; // 처음 눌러진 상태가 아니다.
 1ca:	81 e0       	ldi	r24, 0x01	; 1
 1cc:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <__data_end>
		return 0;		// 아직은 진짜로 눌러진 상태가 아니라 0을 return
 1d0:	80 e0       	ldi	r24, 0x00	; 0
 1d2:	90 e0       	ldi	r25, 0x00	; 0
 1d4:	08 95       	ret
		
	}
	else if(prev_state == 1 && current_state == 0) // 버튼이 눌렸다 떼어진 상태
 1d6:	91 30       	cpi	r25, 0x01	; 1
 1d8:	81 f4       	brne	.+32     	; 0x1fa <get_BUTTON3+0x52>
 1da:	81 11       	cpse	r24, r1
 1dc:	11 c0       	rjmp	.+34     	; 0x200 <get_BUTTON3+0x58>
	{
		prev_state = 0;
 1de:	10 92 94 01 	sts	0x0194, r1	; 0x800194 <__data_end>
 1e2:	2f ef       	ldi	r18, 0xFF	; 255
 1e4:	86 e7       	ldi	r24, 0x76	; 118
 1e6:	91 e0       	ldi	r25, 0x01	; 1
 1e8:	21 50       	subi	r18, 0x01	; 1
 1ea:	80 40       	sbci	r24, 0x00	; 0
 1ec:	90 40       	sbci	r25, 0x00	; 0
 1ee:	e1 f7       	brne	.-8      	; 0x1e8 <get_BUTTON3+0x40>
 1f0:	00 c0       	rjmp	.+0      	; 0x1f2 <get_BUTTON3+0x4a>
 1f2:	00 00       	nop
		_delay_ms(30);	// 노이즈가 지나가기를 기다림
		return 1; // 완전히 눌렸다 떼어진 상태로 인정
 1f4:	81 e0       	ldi	r24, 0x01	; 1
 1f6:	90 e0       	ldi	r25, 0x00	; 0
 1f8:	08 95       	ret
	}
	return 0; // 아직 완전히 sw 을 눌렀다 떼어지지 않은 상태
 1fa:	80 e0       	ldi	r24, 0x00	; 0
 1fc:	90 e0       	ldi	r25, 0x00	; 0
 1fe:	08 95       	ret
 200:	80 e0       	ldi	r24, 0x00	; 0
 202:	90 e0       	ldi	r25, 0x00	; 0
}
 204:	08 95       	ret

00000206 <set_fnd_data>:
uint16_t sec_data;
//uint32_t digit_position=0;  // 출력할 자리수

void set_fnd_data(uint16_t data)
{
	fnd_data = data; 
 206:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <fnd_data+0x1>
 20a:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <fnd_data>
 20e:	08 95       	ret

00000210 <get_fnd_data>:

uint16_t get_fnd_data(void)
{
	return fnd_data; 
	
}
 210:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <fnd_data>
 214:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <fnd_data+0x1>
 218:	08 95       	ret

0000021a <display_fnd>:

//extern uint8_t digit_position;		 // main에 전역 변수로 선언한 경우 이 내용을 추가한다. 
void display_fnd(void)
{
 21a:	cf 93       	push	r28
 21c:	df 93       	push	r29
 21e:	cd b7       	in	r28, 0x3d	; 61
 220:	de b7       	in	r29, 0x3e	; 62
 222:	2a 97       	sbiw	r28, 0x0a	; 10
 224:	0f b6       	in	r0, 0x3f	; 63
 226:	f8 94       	cli
 228:	de bf       	out	0x3e, r29	; 62
 22a:	0f be       	out	0x3f, r0	; 63
 22c:	cd bf       	out	0x3d, r28	; 61
	// uint8_t
	#if 1
	unsigned char fnd_font[] = {0xc0, 0xf9, 0xa4,0xb0, 0x99,0x92, 0x82, 0xd8, 0x80, 0x98};   // common애노우드
 22e:	8a e0       	ldi	r24, 0x0A	; 10
 230:	ee e0       	ldi	r30, 0x0E	; 14
 232:	f1 e0       	ldi	r31, 0x01	; 1
 234:	de 01       	movw	r26, r28
 236:	11 96       	adiw	r26, 0x01	; 1
 238:	01 90       	ld	r0, Z+
 23a:	0d 92       	st	X+, r0
 23c:	8a 95       	dec	r24
 23e:	e1 f7       	brne	.-8      	; 0x238 <display_fnd+0x1e>
	unsigned char fnd_font[] = {~0xc0, ~0xf9, ~0xa4,~0xb0, ~0x99,~0x92, ~0x82, ~0xd8, ~0x80, ~0x98};   // common 캐소우드
	#endif
	
	static uint16_t digit_position = 0; // static 을 선언하면 지역 변수라도 함수 호출 뒤의 값을 그대로 유지 
	
	uint16_t data = get_fnd_data(); 
 240:	e7 df       	rcall	.-50     	; 0x210 <get_fnd_data>
 242:	ac 01       	movw	r20, r24

	switch(digit_position)
 244:	80 91 97 01 	lds	r24, 0x0197	; 0x800197 <digit_position.1621>
 248:	90 91 98 01 	lds	r25, 0x0198	; 0x800198 <digit_position.1621+0x1>
 24c:	81 30       	cpi	r24, 0x01	; 1
 24e:	91 05       	cpc	r25, r1
 250:	61 f1       	breq	.+88     	; 0x2aa <display_fnd+0x90>
 252:	40 f0       	brcs	.+16     	; 0x264 <display_fnd+0x4a>
 254:	82 30       	cpi	r24, 0x02	; 2
 256:	91 05       	cpc	r25, r1
 258:	09 f4       	brne	.+2      	; 0x25c <display_fnd+0x42>
 25a:	53 c0       	rjmp	.+166    	; 0x302 <display_fnd+0xe8>
 25c:	03 97       	sbiw	r24, 0x03	; 3
 25e:	09 f4       	brne	.+2      	; 0x262 <display_fnd+0x48>
 260:	7e c0       	rjmp	.+252    	; 0x35e <display_fnd+0x144>
 262:	aa c0       	rjmp	.+340    	; 0x3b8 <display_fnd+0x19e>
	{
		case 0:   // 1단위
		#if 1
		FND_DIGHT_PORT = 0b10000000;  // 에노우드
 264:	80 e8       	ldi	r24, 0x80	; 128
 266:	88 bb       	out	0x18, r24	; 24
		#else
		FND_DIGHT_PORT = ~0b10000000;  // 캐소우드
		#endif
		FND_DATA_PORT = fnd_font[data %10];  // 0~9 123456789 101112
 268:	9a 01       	movw	r18, r20
 26a:	ad ec       	ldi	r26, 0xCD	; 205
 26c:	bc ec       	ldi	r27, 0xCC	; 204
 26e:	1e d6       	rcall	.+3132   	; 0xeac <__umulhisi3>
 270:	96 95       	lsr	r25
 272:	87 95       	ror	r24
 274:	96 95       	lsr	r25
 276:	87 95       	ror	r24
 278:	96 95       	lsr	r25
 27a:	87 95       	ror	r24
 27c:	9c 01       	movw	r18, r24
 27e:	22 0f       	add	r18, r18
 280:	33 1f       	adc	r19, r19
 282:	88 0f       	add	r24, r24
 284:	99 1f       	adc	r25, r25
 286:	88 0f       	add	r24, r24
 288:	99 1f       	adc	r25, r25
 28a:	88 0f       	add	r24, r24
 28c:	99 1f       	adc	r25, r25
 28e:	82 0f       	add	r24, r18
 290:	93 1f       	adc	r25, r19
 292:	9a 01       	movw	r18, r20
 294:	28 1b       	sub	r18, r24
 296:	39 0b       	sbc	r19, r25
 298:	e1 e0       	ldi	r30, 0x01	; 1
 29a:	f0 e0       	ldi	r31, 0x00	; 0
 29c:	ec 0f       	add	r30, r28
 29e:	fd 1f       	adc	r31, r29
 2a0:	e2 0f       	add	r30, r18
 2a2:	f3 1f       	adc	r31, r19
 2a4:	80 81       	ld	r24, Z
 2a6:	85 bb       	out	0x15, r24	; 21
		break;
 2a8:	87 c0       	rjmp	.+270    	; 0x3b8 <display_fnd+0x19e>
		
		case 1:   // 10단위
		#if 1
		FND_DIGHT_PORT = 0b01000000;  // 에노우드
 2aa:	80 e4       	ldi	r24, 0x40	; 64
 2ac:	88 bb       	out	0x18, r24	; 24
		#else
		FND_DIGHT_PORT = ~0b01000000;   // 캐소우드
		#endif
		FND_DATA_PORT = fnd_font[data /10%10];
 2ae:	9a 01       	movw	r18, r20
 2b0:	ad ec       	ldi	r26, 0xCD	; 205
 2b2:	bc ec       	ldi	r27, 0xCC	; 204
 2b4:	fb d5       	rcall	.+3062   	; 0xeac <__umulhisi3>
 2b6:	ac 01       	movw	r20, r24
 2b8:	56 95       	lsr	r21
 2ba:	47 95       	ror	r20
 2bc:	56 95       	lsr	r21
 2be:	47 95       	ror	r20
 2c0:	56 95       	lsr	r21
 2c2:	47 95       	ror	r20
 2c4:	9a 01       	movw	r18, r20
 2c6:	f2 d5       	rcall	.+3044   	; 0xeac <__umulhisi3>
 2c8:	96 95       	lsr	r25
 2ca:	87 95       	ror	r24
 2cc:	96 95       	lsr	r25
 2ce:	87 95       	ror	r24
 2d0:	96 95       	lsr	r25
 2d2:	87 95       	ror	r24
 2d4:	9c 01       	movw	r18, r24
 2d6:	22 0f       	add	r18, r18
 2d8:	33 1f       	adc	r19, r19
 2da:	88 0f       	add	r24, r24
 2dc:	99 1f       	adc	r25, r25
 2de:	88 0f       	add	r24, r24
 2e0:	99 1f       	adc	r25, r25
 2e2:	88 0f       	add	r24, r24
 2e4:	99 1f       	adc	r25, r25
 2e6:	82 0f       	add	r24, r18
 2e8:	93 1f       	adc	r25, r19
 2ea:	9a 01       	movw	r18, r20
 2ec:	28 1b       	sub	r18, r24
 2ee:	39 0b       	sbc	r19, r25
 2f0:	e1 e0       	ldi	r30, 0x01	; 1
 2f2:	f0 e0       	ldi	r31, 0x00	; 0
 2f4:	ec 0f       	add	r30, r28
 2f6:	fd 1f       	adc	r31, r29
 2f8:	e2 0f       	add	r30, r18
 2fa:	f3 1f       	adc	r31, r19
 2fc:	80 81       	ld	r24, Z
 2fe:	85 bb       	out	0x15, r24	; 21
		break;
 300:	5b c0       	rjmp	.+182    	; 0x3b8 <display_fnd+0x19e>
		
		case 2:   // 100단위   분
		#if 1
		FND_DIGHT_PORT = 0b00100000;  // 에노우드
 302:	80 e2       	ldi	r24, 0x20	; 32
 304:	88 bb       	out	0x18, r24	; 24
		#else
		FND_DIGHT_PORT = ~0b00100000;  // 캐소우드
		#endif
		FND_DATA_PORT = fnd_font[data /100%10];
 306:	9a 01       	movw	r18, r20
 308:	36 95       	lsr	r19
 30a:	27 95       	ror	r18
 30c:	36 95       	lsr	r19
 30e:	27 95       	ror	r18
 310:	ab e7       	ldi	r26, 0x7B	; 123
 312:	b4 e1       	ldi	r27, 0x14	; 20
 314:	cb d5       	rcall	.+2966   	; 0xeac <__umulhisi3>
 316:	ac 01       	movw	r20, r24
 318:	56 95       	lsr	r21
 31a:	47 95       	ror	r20
 31c:	9a 01       	movw	r18, r20
 31e:	ad ec       	ldi	r26, 0xCD	; 205
 320:	bc ec       	ldi	r27, 0xCC	; 204
 322:	c4 d5       	rcall	.+2952   	; 0xeac <__umulhisi3>
 324:	96 95       	lsr	r25
 326:	87 95       	ror	r24
 328:	96 95       	lsr	r25
 32a:	87 95       	ror	r24
 32c:	96 95       	lsr	r25
 32e:	87 95       	ror	r24
 330:	9c 01       	movw	r18, r24
 332:	22 0f       	add	r18, r18
 334:	33 1f       	adc	r19, r19
 336:	88 0f       	add	r24, r24
 338:	99 1f       	adc	r25, r25
 33a:	88 0f       	add	r24, r24
 33c:	99 1f       	adc	r25, r25
 33e:	88 0f       	add	r24, r24
 340:	99 1f       	adc	r25, r25
 342:	82 0f       	add	r24, r18
 344:	93 1f       	adc	r25, r19
 346:	9a 01       	movw	r18, r20
 348:	28 1b       	sub	r18, r24
 34a:	39 0b       	sbc	r19, r25
 34c:	e1 e0       	ldi	r30, 0x01	; 1
 34e:	f0 e0       	ldi	r31, 0x00	; 0
 350:	ec 0f       	add	r30, r28
 352:	fd 1f       	adc	r31, r29
 354:	e2 0f       	add	r30, r18
 356:	f3 1f       	adc	r31, r19
 358:	80 81       	ld	r24, Z
 35a:	85 bb       	out	0x15, r24	; 21
		break;
 35c:	2d c0       	rjmp	.+90     	; 0x3b8 <display_fnd+0x19e>
		
		case 3:   // 1000
		#if 1
		FND_DIGHT_PORT = 0b00010000;  // 에노우드
 35e:	80 e1       	ldi	r24, 0x10	; 16
 360:	88 bb       	out	0x18, r24	; 24
		#else
		FND_DIGHT_PORT = ~0b00010000;  // 캐소우드
		#endif
		FND_DATA_PORT = fnd_font[data /1000%6];
 362:	9a 01       	movw	r18, r20
 364:	36 95       	lsr	r19
 366:	27 95       	ror	r18
 368:	36 95       	lsr	r19
 36a:	27 95       	ror	r18
 36c:	36 95       	lsr	r19
 36e:	27 95       	ror	r18
 370:	a5 ec       	ldi	r26, 0xC5	; 197
 372:	b0 e2       	ldi	r27, 0x20	; 32
 374:	9b d5       	rcall	.+2870   	; 0xeac <__umulhisi3>
 376:	ac 01       	movw	r20, r24
 378:	52 95       	swap	r21
 37a:	42 95       	swap	r20
 37c:	4f 70       	andi	r20, 0x0F	; 15
 37e:	45 27       	eor	r20, r21
 380:	5f 70       	andi	r21, 0x0F	; 15
 382:	45 27       	eor	r20, r21
 384:	9a 01       	movw	r18, r20
 386:	ab ea       	ldi	r26, 0xAB	; 171
 388:	ba ea       	ldi	r27, 0xAA	; 170
 38a:	90 d5       	rcall	.+2848   	; 0xeac <__umulhisi3>
 38c:	96 95       	lsr	r25
 38e:	87 95       	ror	r24
 390:	96 95       	lsr	r25
 392:	87 95       	ror	r24
 394:	9c 01       	movw	r18, r24
 396:	22 0f       	add	r18, r18
 398:	33 1f       	adc	r19, r19
 39a:	82 0f       	add	r24, r18
 39c:	93 1f       	adc	r25, r19
 39e:	88 0f       	add	r24, r24
 3a0:	99 1f       	adc	r25, r25
 3a2:	9a 01       	movw	r18, r20
 3a4:	28 1b       	sub	r18, r24
 3a6:	39 0b       	sbc	r19, r25
 3a8:	e1 e0       	ldi	r30, 0x01	; 1
 3aa:	f0 e0       	ldi	r31, 0x00	; 0
 3ac:	ec 0f       	add	r30, r28
 3ae:	fd 1f       	adc	r31, r29
 3b0:	e2 0f       	add	r30, r18
 3b2:	f3 1f       	adc	r31, r19
 3b4:	80 81       	ld	r24, Z
 3b6:	85 bb       	out	0x15, r24	; 21
		break;
	}
	digit_position++;   // 다음 표시할 자리수
 3b8:	80 91 97 01 	lds	r24, 0x0197	; 0x800197 <digit_position.1621>
 3bc:	90 91 98 01 	lds	r25, 0x0198	; 0x800198 <digit_position.1621+0x1>
 3c0:	01 96       	adiw	r24, 0x01	; 1
	digit_position %= 4;  // digit_position = digit_position % 4
 3c2:	83 70       	andi	r24, 0x03	; 3
 3c4:	99 27       	eor	r25, r25
 3c6:	90 93 98 01 	sts	0x0198, r25	; 0x800198 <digit_position.1621+0x1>
 3ca:	80 93 97 01 	sts	0x0197, r24	; 0x800197 <digit_position.1621>
}
 3ce:	2a 96       	adiw	r28, 0x0a	; 10
 3d0:	0f b6       	in	r0, 0x3f	; 63
 3d2:	f8 94       	cli
 3d4:	de bf       	out	0x3e, r29	; 62
 3d6:	0f be       	out	0x3f, r0	; 63
 3d8:	cd bf       	out	0x3d, r28	; 61
 3da:	df 91       	pop	r29
 3dc:	cf 91       	pop	r28
 3de:	08 95       	ret

000003e0 <init_fnd>:
void init_fnd(void)
{
	FND_DATA_DDR = 0xff;
 3e0:	8f ef       	ldi	r24, 0xFF	; 255
 3e2:	84 bb       	out	0x14, r24	; 20
	FND_DIGHT_DDR |= 0xf0;   // 4567만 1로 3210은 그대로 유지
 3e4:	87 b3       	in	r24, 0x17	; 23
 3e6:	80 6f       	ori	r24, 0xF0	; 240
 3e8:	87 bb       	out	0x17, r24	; 23
	#if 0
	FND_DATA_PORT = ~0x00;   // common 애노우드 FND를 all off
	#else
	FND_DATA_PORT = 0x00;   // 0xff common 케소우드 FND를 all off
 3ea:	15 ba       	out	0x15, r1	; 21
 3ec:	08 95       	ret

000003ee <init_led>:
extern uint32_t del;


void init_led()
{
	DDRA = 0xff; // data direction register
 3ee:	8f ef       	ldi	r24, 0xFF	; 255
 3f0:	8a bb       	out	0x1a, r24	; 26
 3f2:	08 95       	ret

000003f4 <ledalltoggle>:

int toggle = 0; 
void ledalltoggle(void)
{
	
	if(funcyc)
 3f4:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <funcyc>
 3f8:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <funcyc+0x1>
 3fc:	a0 91 a7 01 	lds	r26, 0x01A7	; 0x8001a7 <funcyc+0x2>
 400:	b0 91 a8 01 	lds	r27, 0x01A8	; 0x8001a8 <funcyc+0x3>
 404:	89 2b       	or	r24, r25
 406:	8a 2b       	or	r24, r26
 408:	8b 2b       	or	r24, r27
 40a:	19 f0       	breq	.+6      	; 0x412 <__LOCK_REGION_LENGTH__+0x12>
	{
		PORTA = 0xff;
 40c:	8f ef       	ldi	r24, 0xFF	; 255
 40e:	8b bb       	out	0x1b, r24	; 27
 410:	08 95       	ret
	}
	else 
	{
		PORTA = 0x00;
 412:	1b ba       	out	0x1b, r1	; 27
 414:	08 95       	ret

00000416 <shiftleftledon>:

void shiftleftledon(void)
{
	int i ;
	
		for(i = 0 ; i < 8 ; )
 416:	20 e0       	ldi	r18, 0x00	; 0
 418:	30 e0       	ldi	r19, 0x00	; 0
 41a:	1f c0       	rjmp	.+62     	; 0x45a <shiftleftledon+0x44>
		{	
			if(funcyc)
 41c:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <funcyc>
 420:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <funcyc+0x1>
 424:	a0 91 a7 01 	lds	r26, 0x01A7	; 0x8001a7 <funcyc+0x2>
 428:	b0 91 a8 01 	lds	r27, 0x01A8	; 0x8001a8 <funcyc+0x3>
 42c:	89 2b       	or	r24, r25
 42e:	8a 2b       	or	r24, r26
 430:	8b 2b       	or	r24, r27
 432:	99 f0       	breq	.+38     	; 0x45a <shiftleftledon+0x44>
			{
				
			PORTA = 0x01 << i;
 434:	81 e0       	ldi	r24, 0x01	; 1
 436:	90 e0       	ldi	r25, 0x00	; 0
 438:	02 2e       	mov	r0, r18
 43a:	02 c0       	rjmp	.+4      	; 0x440 <shiftleftledon+0x2a>
 43c:	88 0f       	add	r24, r24
 43e:	99 1f       	adc	r25, r25
 440:	0a 94       	dec	r0
 442:	e2 f7       	brpl	.-8      	; 0x43c <shiftleftledon+0x26>
 444:	8b bb       	out	0x1b, r24	; 27
			
			i++;		// 이쪽으로 빼지 않으면 funcyc가 1이 아닐 때도 for문이 실행된다. 
 446:	2f 5f       	subi	r18, 0xFF	; 255
 448:	3f 4f       	sbci	r19, 0xFF	; 255
			
			funcyc = 0;
 44a:	10 92 a5 01 	sts	0x01A5, r1	; 0x8001a5 <funcyc>
 44e:	10 92 a6 01 	sts	0x01A6, r1	; 0x8001a6 <funcyc+0x1>
 452:	10 92 a7 01 	sts	0x01A7, r1	; 0x8001a7 <funcyc+0x2>
 456:	10 92 a8 01 	sts	0x01A8, r1	; 0x8001a8 <funcyc+0x3>

void shiftleftledon(void)
{
	int i ;
	
		for(i = 0 ; i < 8 ; )
 45a:	28 30       	cpi	r18, 0x08	; 8
 45c:	31 05       	cpc	r19, r1
 45e:	f4 f2       	brlt	.-68     	; 0x41c <shiftleftledon+0x6>
			i++;		// 이쪽으로 빼지 않으면 funcyc가 1이 아닐 때도 for문이 실행된다. 
			
			funcyc = 0;
			}	 
	}
}
 460:	08 95       	ret

00000462 <shiftrightledon>:
void shiftrightledon(void)
{
	int i ;
	
	
		for(i = 0 ; i < 8 ; )
 462:	20 e0       	ldi	r18, 0x00	; 0
 464:	30 e0       	ldi	r19, 0x00	; 0
 466:	1f c0       	rjmp	.+62     	; 0x4a6 <shiftrightledon+0x44>
		{
			if(funcyc)
 468:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <funcyc>
 46c:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <funcyc+0x1>
 470:	a0 91 a7 01 	lds	r26, 0x01A7	; 0x8001a7 <funcyc+0x2>
 474:	b0 91 a8 01 	lds	r27, 0x01A8	; 0x8001a8 <funcyc+0x3>
 478:	89 2b       	or	r24, r25
 47a:	8a 2b       	or	r24, r26
 47c:	8b 2b       	or	r24, r27
 47e:	99 f0       	breq	.+38     	; 0x4a6 <shiftrightledon+0x44>
			{
			PORTA = 0x80 >> i;
 480:	80 e8       	ldi	r24, 0x80	; 128
 482:	90 e0       	ldi	r25, 0x00	; 0
 484:	02 2e       	mov	r0, r18
 486:	02 c0       	rjmp	.+4      	; 0x48c <shiftrightledon+0x2a>
 488:	95 95       	asr	r25
 48a:	87 95       	ror	r24
 48c:	0a 94       	dec	r0
 48e:	e2 f7       	brpl	.-8      	; 0x488 <shiftrightledon+0x26>
 490:	8b bb       	out	0x1b, r24	; 27
			
			
			i++;
 492:	2f 5f       	subi	r18, 0xFF	; 255
 494:	3f 4f       	sbci	r19, 0xFF	; 255
			funcyc = 0; 
 496:	10 92 a5 01 	sts	0x01A5, r1	; 0x8001a5 <funcyc>
 49a:	10 92 a6 01 	sts	0x01A6, r1	; 0x8001a6 <funcyc+0x1>
 49e:	10 92 a7 01 	sts	0x01A7, r1	; 0x8001a7 <funcyc+0x2>
 4a2:	10 92 a8 01 	sts	0x01A8, r1	; 0x8001a8 <funcyc+0x3>
void shiftrightledon(void)
{
	int i ;
	
	
		for(i = 0 ; i < 8 ; )
 4a6:	28 30       	cpi	r18, 0x08	; 8
 4a8:	31 05       	cpc	r19, r1
 4aa:	f4 f2       	brlt	.-68     	; 0x468 <shiftrightledon+0x6>
			i++;
			funcyc = 0; 
			}
		}
	
}
 4ac:	08 95       	ret

000004ae <shiftleftholdledon>:
void shiftleftholdledon(void)
{
	int i ;
	
	
		for(i = 7 ; i >=0 ; )
 4ae:	27 e0       	ldi	r18, 0x07	; 7
 4b0:	30 e0       	ldi	r19, 0x00	; 0
 4b2:	1f c0       	rjmp	.+62     	; 0x4f2 <shiftleftholdledon+0x44>
		{
			if(funcyc)
 4b4:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <funcyc>
 4b8:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <funcyc+0x1>
 4bc:	a0 91 a7 01 	lds	r26, 0x01A7	; 0x8001a7 <funcyc+0x2>
 4c0:	b0 91 a8 01 	lds	r27, 0x01A8	; 0x8001a8 <funcyc+0x3>
 4c4:	89 2b       	or	r24, r25
 4c6:	8a 2b       	or	r24, r26
 4c8:	8b 2b       	or	r24, r27
 4ca:	99 f0       	breq	.+38     	; 0x4f2 <shiftleftholdledon+0x44>
			{
			PORTA = 0xff >> i;
 4cc:	8f ef       	ldi	r24, 0xFF	; 255
 4ce:	90 e0       	ldi	r25, 0x00	; 0
 4d0:	02 2e       	mov	r0, r18
 4d2:	02 c0       	rjmp	.+4      	; 0x4d8 <shiftleftholdledon+0x2a>
 4d4:	95 95       	asr	r25
 4d6:	87 95       	ror	r24
 4d8:	0a 94       	dec	r0
 4da:	e2 f7       	brpl	.-8      	; 0x4d4 <shiftleftholdledon+0x26>
 4dc:	8b bb       	out	0x1b, r24	; 27
			
			i--;
 4de:	21 50       	subi	r18, 0x01	; 1
 4e0:	31 09       	sbc	r19, r1
			
			funcyc = 0; 
 4e2:	10 92 a5 01 	sts	0x01A5, r1	; 0x8001a5 <funcyc>
 4e6:	10 92 a6 01 	sts	0x01A6, r1	; 0x8001a6 <funcyc+0x1>
 4ea:	10 92 a7 01 	sts	0x01A7, r1	; 0x8001a7 <funcyc+0x2>
 4ee:	10 92 a8 01 	sts	0x01A8, r1	; 0x8001a8 <funcyc+0x3>
void shiftleftholdledon(void)
{
	int i ;
	
	
		for(i = 7 ; i >=0 ; )
 4f2:	33 23       	and	r19, r19
 4f4:	fc f6       	brge	.-66     	; 0x4b4 <shiftleftholdledon+0x6>
			i--;
			
			funcyc = 0; 
			}
		}
}
 4f6:	08 95       	ret

000004f8 <shiftrightholdledon>:

void shiftrightholdledon(void)
{
	int i ;
	
		for(i = 7 ; i >=0 ; )
 4f8:	27 e0       	ldi	r18, 0x07	; 7
 4fa:	30 e0       	ldi	r19, 0x00	; 0
 4fc:	1f c0       	rjmp	.+62     	; 0x53c <shiftrightholdledon+0x44>
		{
			if(funcyc)
 4fe:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <funcyc>
 502:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <funcyc+0x1>
 506:	a0 91 a7 01 	lds	r26, 0x01A7	; 0x8001a7 <funcyc+0x2>
 50a:	b0 91 a8 01 	lds	r27, 0x01A8	; 0x8001a8 <funcyc+0x3>
 50e:	89 2b       	or	r24, r25
 510:	8a 2b       	or	r24, r26
 512:	8b 2b       	or	r24, r27
 514:	99 f0       	breq	.+38     	; 0x53c <shiftrightholdledon+0x44>
			{
			PORTA = 0xff << i;
 516:	8f ef       	ldi	r24, 0xFF	; 255
 518:	90 e0       	ldi	r25, 0x00	; 0
 51a:	02 2e       	mov	r0, r18
 51c:	02 c0       	rjmp	.+4      	; 0x522 <shiftrightholdledon+0x2a>
 51e:	88 0f       	add	r24, r24
 520:	99 1f       	adc	r25, r25
 522:	0a 94       	dec	r0
 524:	e2 f7       	brpl	.-8      	; 0x51e <shiftrightholdledon+0x26>
 526:	8b bb       	out	0x1b, r24	; 27
			
			i--;
 528:	21 50       	subi	r18, 0x01	; 1
 52a:	31 09       	sbc	r19, r1
			
			funcyc = 0; 
 52c:	10 92 a5 01 	sts	0x01A5, r1	; 0x8001a5 <funcyc>
 530:	10 92 a6 01 	sts	0x01A6, r1	; 0x8001a6 <funcyc+0x1>
 534:	10 92 a7 01 	sts	0x01A7, r1	; 0x8001a7 <funcyc+0x2>
 538:	10 92 a8 01 	sts	0x01A8, r1	; 0x8001a8 <funcyc+0x3>

void shiftrightholdledon(void)
{
	int i ;
	
		for(i = 7 ; i >=0 ; )
 53c:	33 23       	and	r19, r19
 53e:	fc f6       	brge	.-66     	; 0x4fe <shiftrightholdledon+0x6>
			i--;
			
			funcyc = 0; 
			}
		}
}
 540:	08 95       	ret

00000542 <f_off>:
void f_off(void)
{
	int h,l;
	
	
		for(int i = 0; i < 4; )
 542:	20 e0       	ldi	r18, 0x00	; 0
 544:	30 e0       	ldi	r19, 0x00	; 0
 546:	29 c0       	rjmp	.+82     	; 0x59a <f_off+0x58>
		{
			if(funcyc)
 548:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <funcyc>
 54c:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <funcyc+0x1>
 550:	a0 91 a7 01 	lds	r26, 0x01A7	; 0x8001a7 <funcyc+0x2>
 554:	b0 91 a8 01 	lds	r27, 0x01A8	; 0x8001a8 <funcyc+0x3>
 558:	89 2b       	or	r24, r25
 55a:	8a 2b       	or	r24, r26
 55c:	8b 2b       	or	r24, r27
 55e:	e9 f0       	breq	.+58     	; 0x59a <f_off+0x58>
			{
			h = 0x80 >> i;
 560:	80 e8       	ldi	r24, 0x80	; 128
 562:	90 e0       	ldi	r25, 0x00	; 0
 564:	ac 01       	movw	r20, r24
 566:	02 2e       	mov	r0, r18
 568:	02 c0       	rjmp	.+4      	; 0x56e <f_off+0x2c>
 56a:	55 95       	asr	r21
 56c:	47 95       	ror	r20
 56e:	0a 94       	dec	r0
 570:	e2 f7       	brpl	.-8      	; 0x56a <f_off+0x28>
			l = 0x01 << i;
 572:	81 e0       	ldi	r24, 0x01	; 1
 574:	90 e0       	ldi	r25, 0x00	; 0
 576:	02 2e       	mov	r0, r18
 578:	02 c0       	rjmp	.+4      	; 0x57e <f_off+0x3c>
 57a:	88 0f       	add	r24, r24
 57c:	99 1f       	adc	r25, r25
 57e:	0a 94       	dec	r0
 580:	e2 f7       	brpl	.-8      	; 0x57a <f_off+0x38>
			PORTA = h | l ;
 582:	84 2b       	or	r24, r20
 584:	8b bb       	out	0x1b, r24	; 27
			
			i++; 
 586:	2f 5f       	subi	r18, 0xFF	; 255
 588:	3f 4f       	sbci	r19, 0xFF	; 255
			
			funcyc = 0;
 58a:	10 92 a5 01 	sts	0x01A5, r1	; 0x8001a5 <funcyc>
 58e:	10 92 a6 01 	sts	0x01A6, r1	; 0x8001a6 <funcyc+0x1>
 592:	10 92 a7 01 	sts	0x01A7, r1	; 0x8001a7 <funcyc+0x2>
 596:	10 92 a8 01 	sts	0x01A8, r1	; 0x8001a8 <funcyc+0x3>
void f_off(void)
{
	int h,l;
	
	
		for(int i = 0; i < 4; )
 59a:	24 30       	cpi	r18, 0x04	; 4
 59c:	31 05       	cpc	r19, r1
 59e:	a4 f2       	brlt	.-88     	; 0x548 <f_off+0x6>
			i++; 
			
			funcyc = 0;
			} 
		}
}
 5a0:	08 95       	ret

000005a2 <flower_on>:
void flower_on(void)
{
	int h2,l2;
	
	
		for(int i = 0; i < 4;)
 5a2:	20 e0       	ldi	r18, 0x00	; 0
 5a4:	30 e0       	ldi	r19, 0x00	; 0
 5a6:	29 c0       	rjmp	.+82     	; 0x5fa <flower_on+0x58>
		{
			if(funcyc)
 5a8:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <funcyc>
 5ac:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <funcyc+0x1>
 5b0:	a0 91 a7 01 	lds	r26, 0x01A7	; 0x8001a7 <funcyc+0x2>
 5b4:	b0 91 a8 01 	lds	r27, 0x01A8	; 0x8001a8 <funcyc+0x3>
 5b8:	89 2b       	or	r24, r25
 5ba:	8a 2b       	or	r24, r26
 5bc:	8b 2b       	or	r24, r27
 5be:	e9 f0       	breq	.+58     	; 0x5fa <flower_on+0x58>
			{
			h2 = 0x10 << i;
 5c0:	80 e1       	ldi	r24, 0x10	; 16
 5c2:	90 e0       	ldi	r25, 0x00	; 0
 5c4:	ac 01       	movw	r20, r24
 5c6:	02 2e       	mov	r0, r18
 5c8:	02 c0       	rjmp	.+4      	; 0x5ce <flower_on+0x2c>
 5ca:	44 0f       	add	r20, r20
 5cc:	55 1f       	adc	r21, r21
 5ce:	0a 94       	dec	r0
 5d0:	e2 f7       	brpl	.-8      	; 0x5ca <flower_on+0x28>
			l2 = 0x08 >> i;
 5d2:	88 e0       	ldi	r24, 0x08	; 8
 5d4:	90 e0       	ldi	r25, 0x00	; 0
 5d6:	02 2e       	mov	r0, r18
 5d8:	02 c0       	rjmp	.+4      	; 0x5de <flower_on+0x3c>
 5da:	95 95       	asr	r25
 5dc:	87 95       	ror	r24
 5de:	0a 94       	dec	r0
 5e0:	e2 f7       	brpl	.-8      	; 0x5da <flower_on+0x38>
			PORTA = h2 | l2 ;
 5e2:	84 2b       	or	r24, r20
 5e4:	8b bb       	out	0x1b, r24	; 27
			
			i++;
 5e6:	2f 5f       	subi	r18, 0xFF	; 255
 5e8:	3f 4f       	sbci	r19, 0xFF	; 255
			 
			funcyc = 0;
 5ea:	10 92 a5 01 	sts	0x01A5, r1	; 0x8001a5 <funcyc>
 5ee:	10 92 a6 01 	sts	0x01A6, r1	; 0x8001a6 <funcyc+0x1>
 5f2:	10 92 a7 01 	sts	0x01A7, r1	; 0x8001a7 <funcyc+0x2>
 5f6:	10 92 a8 01 	sts	0x01A8, r1	; 0x8001a8 <funcyc+0x3>
void flower_on(void)
{
	int h2,l2;
	
	
		for(int i = 0; i < 4;)
 5fa:	24 30       	cpi	r18, 0x04	; 4
 5fc:	31 05       	cpc	r19, r1
 5fe:	a4 f2       	brlt	.-88     	; 0x5a8 <flower_on+0x6>
			i++;
			 
			funcyc = 0;
			}
		}
 600:	08 95       	ret

00000602 <__vector_16>:
// 3. 8 bit Timer OV : 4us * 256 = 1.024ms
// 256개의 pulse 를 count 하면 이곳으로 온다
//

ISR(TIMER0_OVF_vect) // 인터럽트 루틴을 길게 짤 수록 output delay가 증가하여 원하는 시간에 출력이 나오지 않음 
{
 602:	1f 92       	push	r1
 604:	0f 92       	push	r0
 606:	0f b6       	in	r0, 0x3f	; 63
 608:	0f 92       	push	r0
 60a:	11 24       	eor	r1, r1
 60c:	0b b6       	in	r0, 0x3b	; 59
 60e:	0f 92       	push	r0
 610:	cf 92       	push	r12
 612:	df 92       	push	r13
 614:	ef 92       	push	r14
 616:	ff 92       	push	r15
 618:	2f 93       	push	r18
 61a:	3f 93       	push	r19
 61c:	4f 93       	push	r20
 61e:	5f 93       	push	r21
 620:	6f 93       	push	r22
 622:	7f 93       	push	r23
 624:	8f 93       	push	r24
 626:	9f 93       	push	r25
 628:	af 93       	push	r26
 62a:	bf 93       	push	r27
 62c:	ef 93       	push	r30
 62e:	ff 93       	push	r31
	TCNT0 = 6; // TCNT를 6~256 == > 정확히 1ms 를 유지하기 위해 
 630:	86 e0       	ldi	r24, 0x06	; 6
 632:	82 bf       	out	0x32, r24	; 50
			   // TINT 0 OVF INT 
	ms_count++;
 634:	c0 90 b5 01 	lds	r12, 0x01B5	; 0x8001b5 <ms_count>
 638:	d0 90 b6 01 	lds	r13, 0x01B6	; 0x8001b6 <ms_count+0x1>
 63c:	e0 90 b7 01 	lds	r14, 0x01B7	; 0x8001b7 <ms_count+0x2>
 640:	f0 90 b8 01 	lds	r15, 0x01B8	; 0x8001b8 <ms_count+0x3>
 644:	2f ef       	ldi	r18, 0xFF	; 255
 646:	c2 1a       	sub	r12, r18
 648:	d2 0a       	sbc	r13, r18
 64a:	e2 0a       	sbc	r14, r18
 64c:	f2 0a       	sbc	r15, r18
 64e:	c0 92 b5 01 	sts	0x01B5, r12	; 0x8001b5 <ms_count>
 652:	d0 92 b6 01 	sts	0x01B6, r13	; 0x8001b6 <ms_count+0x1>
 656:	e0 92 b7 01 	sts	0x01B7, r14	; 0x8001b7 <ms_count+0x2>
 65a:	f0 92 b8 01 	sts	0x01B8, r15	; 0x8001b8 <ms_count+0x3>
	ms_count2++; 
 65e:	80 91 ad 01 	lds	r24, 0x01AD	; 0x8001ad <ms_count2>
 662:	90 91 ae 01 	lds	r25, 0x01AE	; 0x8001ae <ms_count2+0x1>
 666:	a0 91 af 01 	lds	r26, 0x01AF	; 0x8001af <ms_count2+0x2>
 66a:	b0 91 b0 01 	lds	r27, 0x01B0	; 0x8001b0 <ms_count2+0x3>
 66e:	bc 01       	movw	r22, r24
 670:	cd 01       	movw	r24, r26
 672:	6f 5f       	subi	r22, 0xFF	; 255
 674:	7f 4f       	sbci	r23, 0xFF	; 255
 676:	8f 4f       	sbci	r24, 0xFF	; 255
 678:	9f 4f       	sbci	r25, 0xFF	; 255
 67a:	60 93 ad 01 	sts	0x01AD, r22	; 0x8001ad <ms_count2>
 67e:	70 93 ae 01 	sts	0x01AE, r23	; 0x8001ae <ms_count2+0x1>
 682:	80 93 af 01 	sts	0x01AF, r24	; 0x8001af <ms_count2+0x2>
 686:	90 93 b0 01 	sts	0x01B0, r25	; 0x8001b0 <ms_count2+0x3>
	
	del = 300; // delay ms 변수 300ms
 68a:	2c e2       	ldi	r18, 0x2C	; 44
 68c:	31 e0       	ldi	r19, 0x01	; 1
 68e:	40 e0       	ldi	r20, 0x00	; 0
 690:	50 e0       	ldi	r21, 0x00	; 0
 692:	20 93 a9 01 	sts	0x01A9, r18	; 0x8001a9 <del>
 696:	30 93 aa 01 	sts	0x01AA, r19	; 0x8001aa <del+0x1>
 69a:	40 93 ab 01 	sts	0x01AB, r20	; 0x8001ab <del+0x2>
 69e:	50 93 ac 01 	sts	0x01AC, r21	; 0x8001ac <del+0x3>
	if(ms_count2 % del == 0) 
 6a2:	d9 d3       	rcall	.+1970   	; 0xe56 <__udivmodsi4>
 6a4:	67 2b       	or	r22, r23
 6a6:	68 2b       	or	r22, r24
 6a8:	69 2b       	or	r22, r25
 6aa:	99 f4       	brne	.+38     	; 0x6d2 <__vector_16+0xd0>
	{
		
		funcyc++;
 6ac:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <funcyc>
 6b0:	90 91 a6 01 	lds	r25, 0x01A6	; 0x8001a6 <funcyc+0x1>
 6b4:	a0 91 a7 01 	lds	r26, 0x01A7	; 0x8001a7 <funcyc+0x2>
 6b8:	b0 91 a8 01 	lds	r27, 0x01A8	; 0x8001a8 <funcyc+0x3>
 6bc:	01 96       	adiw	r24, 0x01	; 1
 6be:	a1 1d       	adc	r26, r1
 6c0:	b1 1d       	adc	r27, r1
 6c2:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <funcyc>
 6c6:	90 93 a6 01 	sts	0x01A6, r25	; 0x8001a6 <funcyc+0x1>
 6ca:	a0 93 a7 01 	sts	0x01A7, r26	; 0x8001a7 <funcyc+0x2>
 6ce:	b0 93 a8 01 	sts	0x01A8, r27	; 0x8001a8 <funcyc+0x3>
	}
	
	if (ms_count >= 1000)   // 1000ms ==> 1sec
 6d2:	88 ee       	ldi	r24, 0xE8	; 232
 6d4:	c8 16       	cp	r12, r24
 6d6:	83 e0       	ldi	r24, 0x03	; 3
 6d8:	d8 06       	cpc	r13, r24
 6da:	e1 04       	cpc	r14, r1
 6dc:	f1 04       	cpc	r15, r1
 6de:	e0 f0       	brcs	.+56     	; 0x718 <__vector_16+0x116>
	{
		ms_count=0;
 6e0:	10 92 b5 01 	sts	0x01B5, r1	; 0x8001b5 <ms_count>
 6e4:	10 92 b6 01 	sts	0x01B6, r1	; 0x8001b6 <ms_count+0x1>
 6e8:	10 92 b7 01 	sts	0x01B7, r1	; 0x8001b7 <ms_count+0x2>
 6ec:	10 92 b8 01 	sts	0x01B8, r1	; 0x8001b8 <ms_count+0x3>
		sec_count++;    // sec counter 증가
 6f0:	80 91 b1 01 	lds	r24, 0x01B1	; 0x8001b1 <sec_count>
 6f4:	90 91 b2 01 	lds	r25, 0x01B2	; 0x8001b2 <sec_count+0x1>
 6f8:	a0 91 b3 01 	lds	r26, 0x01B3	; 0x8001b3 <sec_count+0x2>
 6fc:	b0 91 b4 01 	lds	r27, 0x01B4	; 0x8001b4 <sec_count+0x3>
 700:	01 96       	adiw	r24, 0x01	; 1
 702:	a1 1d       	adc	r26, r1
 704:	b1 1d       	adc	r27, r1
 706:	80 93 b1 01 	sts	0x01B1, r24	; 0x8001b1 <sec_count>
 70a:	90 93 b2 01 	sts	0x01B2, r25	; 0x8001b2 <sec_count+0x1>
 70e:	a0 93 b3 01 	sts	0x01B3, r26	; 0x8001b3 <sec_count+0x2>
 712:	b0 93 b4 01 	sts	0x01B4, r27	; 0x8001b4 <sec_count+0x3>
		inc_time_sec(); // 1초에 한번 씩 call 
 716:	96 d1       	rcall	.+812    	; 0xa44 <inc_time_sec>
	}
	if (ms_count%4 == 0)  //4ms 마다 fnd를 display
 718:	80 91 b5 01 	lds	r24, 0x01B5	; 0x8001b5 <ms_count>
 71c:	90 91 b6 01 	lds	r25, 0x01B6	; 0x8001b6 <ms_count+0x1>
 720:	a0 91 b7 01 	lds	r26, 0x01B7	; 0x8001b7 <ms_count+0x2>
 724:	b0 91 b8 01 	lds	r27, 0x01B8	; 0x8001b8 <ms_count+0x3>
 728:	83 70       	andi	r24, 0x03	; 3
 72a:	99 27       	eor	r25, r25
 72c:	aa 27       	eor	r26, r26
 72e:	bb 27       	eor	r27, r27
 730:	89 2b       	or	r24, r25
 732:	8a 2b       	or	r24, r26
 734:	8b 2b       	or	r24, r27
		display_fnd();
 736:	09 f4       	brne	.+2      	; 0x73a <__vector_16+0x138>
 738:	70 dd       	rcall	.-1312   	; 0x21a <display_fnd>
		
	if(stopwatch_state == RUN)
 73a:	80 91 c2 01 	lds	r24, 0x01C2	; 0x8001c2 <stopwatch_state>
 73e:	90 91 c3 01 	lds	r25, 0x01C3	; 0x8001c3 <stopwatch_state+0x1>
		inc_stopwatch_clock();
 742:	01 97       	sbiw	r24, 0x01	; 1
 744:	09 f4       	brne	.+2      	; 0x748 <__vector_16+0x146>
		
	if(get_BUTTON3())			// timer reset 
 746:	e5 d0       	rcall	.+458    	; 0x912 <inc_stopwatch_clock>
 748:	2f dd       	rcall	.-1442   	; 0x1a8 <get_BUTTON3>
 74a:	89 2b       	or	r24, r25
 74c:	51 f0       	breq	.+20     	; 0x762 <__vector_16+0x160>
	{
		time_clock.sec = 0;
 74e:	e4 ec       	ldi	r30, 0xC4	; 196
 750:	f1 e0       	ldi	r31, 0x01	; 1
 752:	12 82       	std	Z+2, r1	; 0x02
		time_clock.min = 0;
 754:	11 82       	std	Z+1, r1	; 0x01
		time_clock.hour = 0;
 756:	10 82       	st	Z, r1
		
		PORTF &= ~0x06;
 758:	e2 e6       	ldi	r30, 0x62	; 98
 75a:	f0 e0       	ldi	r31, 0x00	; 0
 75c:	80 81       	ld	r24, Z
 75e:	89 7f       	andi	r24, 0xF9	; 249
 760:	80 83       	st	Z, r24
	}
	
	
	count12++;
 762:	80 91 a3 01 	lds	r24, 0x01A3	; 0x8001a3 <count12>
 766:	90 91 a4 01 	lds	r25, 0x01A4	; 0x8001a4 <count12+0x1>
 76a:	01 96       	adiw	r24, 0x01	; 1
 76c:	90 93 a4 01 	sts	0x01A4, r25	; 0x8001a4 <count12+0x1>
 770:	80 93 a3 01 	sts	0x01A3, r24	; 0x8001a3 <count12>
	if(count12 >=500)// 0.512sec : 512ms 오버플로우 500회 이상일 때 조건문 실행
 774:	80 91 a3 01 	lds	r24, 0x01A3	; 0x8001a3 <count12>
 778:	90 91 a4 01 	lds	r25, 0x01A4	; 0x8001a4 <count12+0x1>
 77c:	84 3f       	cpi	r24, 0xF4	; 244
 77e:	91 40       	sbci	r25, 0x01	; 1
 780:	1c f1       	brlt	.+70     	; 0x7c8 <__vector_16+0x1c6>
	{
		count12 = 0;			// counter initial
 782:	10 92 a4 01 	sts	0x01A4, r1	; 0x8001a4 <count12+0x1>
 786:	10 92 a3 01 	sts	0x01A3, r1	; 0x8001a3 <count12>
		state = !state;		// reverse led state
 78a:	20 91 a1 01 	lds	r18, 0x01A1	; 0x8001a1 <state>
 78e:	30 91 a2 01 	lds	r19, 0x01A2	; 0x8001a2 <state+0x1>
 792:	81 e0       	ldi	r24, 0x01	; 1
 794:	90 e0       	ldi	r25, 0x00	; 0
 796:	23 2b       	or	r18, r19
 798:	11 f0       	breq	.+4      	; 0x79e <__vector_16+0x19c>
 79a:	80 e0       	ldi	r24, 0x00	; 0
 79c:	90 e0       	ldi	r25, 0x00	; 0
 79e:	90 93 a2 01 	sts	0x01A2, r25	; 0x8001a2 <state+0x1>
 7a2:	80 93 a1 01 	sts	0x01A1, r24	; 0x8001a1 <state>
		if(state)
 7a6:	80 91 a1 01 	lds	r24, 0x01A1	; 0x8001a1 <state>
 7aa:	90 91 a2 01 	lds	r25, 0x01A2	; 0x8001a2 <state+0x1>
 7ae:	89 2b       	or	r24, r25
 7b0:	31 f0       	breq	.+12     	; 0x7be <__vector_16+0x1bc>
		{
			PORTF |= 0x01;	// LED ON 해당하는 값만 ON시키기 위해 OR연산자 사용
 7b2:	e2 e6       	ldi	r30, 0x62	; 98
 7b4:	f0 e0       	ldi	r31, 0x00	; 0
 7b6:	80 81       	ld	r24, Z
 7b8:	81 60       	ori	r24, 0x01	; 1
 7ba:	80 83       	st	Z, r24
 7bc:	05 c0       	rjmp	.+10     	; 0x7c8 <__vector_16+0x1c6>
		}
		else
		{
			PORTF &= ~0x01;	// LED OFF 해당하는 PIN만 OFF시키기 위해 AND연산자 사용
 7be:	e2 e6       	ldi	r30, 0x62	; 98
 7c0:	f0 e0       	ldi	r31, 0x00	; 0
 7c2:	80 81       	ld	r24, Z
 7c4:	8e 7f       	andi	r24, 0xFE	; 254
		}
		
	}
	
	if(get_BUTTON1())
 7c6:	80 83       	st	Z, r24
 7c8:	91 dc       	rcall	.-1758   	; 0xec <get_BUTTON1>
 7ca:	89 2b       	or	r24, r25
 7cc:	29 f1       	breq	.+74     	; 0x818 <__vector_16+0x216>
	{
		
		state1 = !state1;		// reverse led state
 7ce:	20 91 9f 01 	lds	r18, 0x019F	; 0x80019f <state1>
 7d2:	30 91 a0 01 	lds	r19, 0x01A0	; 0x8001a0 <state1+0x1>
 7d6:	81 e0       	ldi	r24, 0x01	; 1
 7d8:	90 e0       	ldi	r25, 0x00	; 0
 7da:	23 2b       	or	r18, r19
 7dc:	11 f0       	breq	.+4      	; 0x7e2 <__vector_16+0x1e0>
 7de:	80 e0       	ldi	r24, 0x00	; 0
 7e0:	90 e0       	ldi	r25, 0x00	; 0
 7e2:	90 93 a0 01 	sts	0x01A0, r25	; 0x8001a0 <state1+0x1>
 7e6:	80 93 9f 01 	sts	0x019F, r24	; 0x80019f <state1>
		if(state1)
 7ea:	80 91 9f 01 	lds	r24, 0x019F	; 0x80019f <state1>
 7ee:	90 91 a0 01 	lds	r25, 0x01A0	; 0x8001a0 <state1+0x1>
 7f2:	89 2b       	or	r24, r25
 7f4:	49 f0       	breq	.+18     	; 0x808 <__vector_16+0x206>
		{
			PORTF |= 0x04;
 7f6:	e2 e6       	ldi	r30, 0x62	; 98
 7f8:	f0 e0       	ldi	r31, 0x00	; 0
 7fa:	80 81       	ld	r24, Z
 7fc:	84 60       	ori	r24, 0x04	; 4
 7fe:	80 83       	st	Z, r24
			PORTF &= ~0x02;	// LED ON 해당하는 값만 ON시키기 위해 OR연산자 사용
 800:	80 81       	ld	r24, Z
 802:	8d 7f       	andi	r24, 0xFD	; 253
 804:	80 83       	st	Z, r24
 806:	08 c0       	rjmp	.+16     	; 0x818 <__vector_16+0x216>
		}
		else
		{
			PORTF |= 0x02;
 808:	e2 e6       	ldi	r30, 0x62	; 98
 80a:	f0 e0       	ldi	r31, 0x00	; 0
 80c:	80 81       	ld	r24, Z
 80e:	82 60       	ori	r24, 0x02	; 2
 810:	80 83       	st	Z, r24
			PORTF &= ~0x04;	// LED OFF 해당하는 PIN만 OFF시키기 위해 AND연산자 사용
 812:	80 81       	ld	r24, Z
 814:	8b 7f       	andi	r24, 0xFB	; 251
 816:	80 83       	st	Z, r24
	}
	
	
	
		
}
 818:	ff 91       	pop	r31
 81a:	ef 91       	pop	r30
 81c:	bf 91       	pop	r27
 81e:	af 91       	pop	r26
 820:	9f 91       	pop	r25
 822:	8f 91       	pop	r24
 824:	7f 91       	pop	r23
 826:	6f 91       	pop	r22
 828:	5f 91       	pop	r21
 82a:	4f 91       	pop	r20
 82c:	3f 91       	pop	r19
 82e:	2f 91       	pop	r18
 830:	ff 90       	pop	r15
 832:	ef 90       	pop	r14
 834:	df 90       	pop	r13
 836:	cf 90       	pop	r12
 838:	0f 90       	pop	r0
 83a:	0b be       	out	0x3b, r0	; 59
 83c:	0f 90       	pop	r0
 83e:	0f be       	out	0x3f, r0	; 63
 840:	0f 90       	pop	r0
 842:	1f 90       	pop	r1
 844:	18 95       	reti

00000846 <init_timer0>:
	}
}

void init_timer0()
{
	TCNT0 = 6; 
 846:	86 e0       	ldi	r24, 0x06	; 6
 848:	82 bf       	out	0x32, r24	; 50
	
	DDRF = 0x01 + 0x02 + 0x04;
 84a:	87 e0       	ldi	r24, 0x07	; 7
 84c:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <__TEXT_REGION_LENGTH__+0x7e0061>
	
	PORTF |= 0x02;
 850:	e2 e6       	ldi	r30, 0x62	; 98
 852:	f0 e0       	ldi	r31, 0x00	; 0
 854:	80 81       	ld	r24, Z
 856:	82 60       	ori	r24, 0x02	; 2
 858:	80 83       	st	Z, r24
	
	TCCR0 |= (1 << CS02) | (0 << CS01) | (0 << CS00);  //  분주비를 64로 설정
 85a:	83 b7       	in	r24, 0x33	; 51
 85c:	84 60       	ori	r24, 0x04	; 4
 85e:	83 bf       	out	0x33, r24	; 51
	
	TIMSK |= (1 << TOIE0);
 860:	87 b7       	in	r24, 0x37	; 55
 862:	81 60       	ori	r24, 0x01	; 1
 864:	87 bf       	out	0x37, r24	; 55
 866:	08 95       	ret

00000868 <main>:
int mode = WATCH;
 


int main(void)
{
 868:	cf 93       	push	r28
 86a:	df 93       	push	r29
 86c:	00 d0       	rcall	.+0      	; 0x86e <main+0x6>
 86e:	1f 92       	push	r1
 870:	cd b7       	in	r28, 0x3d	; 61
 872:	de b7       	in	r29, 0x3e	; 62
	TIME myTIME; // 시계를 구동 
	
	init_led(); 
 874:	bc dd       	rcall	.-1160   	; 0x3ee <init_led>
	init_fnd();
 876:	b4 dd       	rcall	.-1176   	; 0x3e0 <init_fnd>
	init_BUTTON();
 878:	35 dc       	rcall	.-1942   	; 0xe4 <init_BUTTON>
	init_uart0(); // UART0를 초기화 한다. 
 87a:	39 d1       	rcall	.+626    	; 0xaee <init_uart0>
 87c:	fa d1       	rcall	.+1012   	; 0xc72 <init_UART1>
	init_UART1(); // UART1 initial 
 87e:	80 e0       	ldi	r24, 0x00	; 0
 880:	91 e0       	ldi	r25, 0x01	; 1
	stdout = &OUTPUT; // for printf /fprintf(stdout, "test"); ==> printf stdin : 입력 
 882:	90 93 76 02 	sts	0x0276, r25	; 0x800276 <__iob+0x3>
 886:	80 93 75 02 	sts	0x0275, r24	; 0x800275 <__iob+0x2>
 88a:	dd df       	rcall	.-70     	; 0x846 <init_timer0>
	init_timer0();
 88c:	78 94       	sei
 88e:	10 92 9e 01 	sts	0x019E, r1	; 0x80019e <mode+0x1>
	sei();			 // global interrupt 활성화 
	
	mode = WATCH; // 시계모드로 시작 
 892:	10 92 9d 01 	sts	0x019D, r1	; 0x80019d <mode>
 896:	10 92 c3 01 	sts	0x01C3, r1	; 0x8001c3 <stopwatch_state+0x1>
	stopwatch_state = STOP; 
 89a:	10 92 c2 01 	sts	0x01C2, r1	; 0x8001c2 <stopwatch_state>
 89e:	80 91 9d 01 	lds	r24, 0x019D	; 0x80019d <mode>

	
	
	while (1)
	{
		switch(mode)
 8a2:	90 91 9e 01 	lds	r25, 0x019E	; 0x80019e <mode+0x1>
 8a6:	00 97       	sbiw	r24, 0x00	; 0
 8a8:	19 f0       	breq	.+6      	; 0x8b0 <main+0x48>
 8aa:	01 97       	sbiw	r24, 0x01	; 1
 8ac:	b9 f0       	breq	.+46     	; 0x8dc <main+0x74>
 8ae:	2e c0       	rjmp	.+92     	; 0x90c <main+0xa4>
 8b0:	ce 01       	movw	r24, r28
		{
			case WATCH : 
			get_time_clock(&myTIME);
 8b2:	01 96       	adiw	r24, 0x01	; 1
 8b4:	bc d0       	rcall	.+376    	; 0xa2e <get_time_clock>
 8b6:	2a 81       	ldd	r18, Y+2	; 0x02
 8b8:	8b 81       	ldd	r24, Y+3	; 0x03
			set_fnd_data(myTIME.min*100 + myTIME.sec);
 8ba:	90 e0       	ldi	r25, 0x00	; 0
 8bc:	34 e6       	ldi	r19, 0x64	; 100
 8be:	23 9f       	mul	r18, r19
 8c0:	80 0d       	add	r24, r0
 8c2:	91 1d       	adc	r25, r1
 8c4:	11 24       	eor	r1, r1
 8c6:	9f dc       	rcall	.-1730   	; 0x206 <set_fnd_data>
 8c8:	11 dc       	rcall	.-2014   	; 0xec <get_BUTTON1>
			if(get_BUTTON1())
 8ca:	89 2b       	or	r24, r25
 8cc:	f9 f0       	breq	.+62     	; 0x90c <main+0xa4>
 8ce:	81 e0       	ldi	r24, 0x01	; 1
 8d0:	90 e0       	ldi	r25, 0x00	; 0
			{
				mode = STOPWATCH; 
 8d2:	90 93 9e 01 	sts	0x019E, r25	; 0x80019e <mode+0x1>
 8d6:	80 93 9d 01 	sts	0x019D, r24	; 0x80019d <mode>
 8da:	18 c0       	rjmp	.+48     	; 0x90c <main+0xa4>
 8dc:	80 91 c2 01 	lds	r24, 0x01C2	; 0x8001c2 <stopwatch_state>
			}
			break;
			
			case STOPWATCH :
			switch (stopwatch_state)
 8e0:	90 91 c3 01 	lds	r25, 0x01C3	; 0x8001c3 <stopwatch_state+0x1>
 8e4:	81 30       	cpi	r24, 0x01	; 1
 8e6:	91 05       	cpc	r25, r1
 8e8:	39 f0       	breq	.+14     	; 0x8f8 <main+0x90>
 8ea:	82 30       	cpi	r24, 0x02	; 2
 8ec:	91 05       	cpc	r25, r1
 8ee:	31 f0       	breq	.+12     	; 0x8fc <main+0x94>
			{
				case STOP :
				stopwatch_stop(); 
 8f0:	89 2b       	or	r24, r25
 8f2:	29 f4       	brne	.+10     	; 0x8fe <main+0x96>
				break;
 8f4:	66 d0       	rcall	.+204    	; 0x9c2 <stopwatch_stop>
				case RUN :
				stopwatch_run();
 8f6:	03 c0       	rjmp	.+6      	; 0x8fe <main+0x96>
				break;
 8f8:	57 d0       	rcall	.+174    	; 0x9a8 <stopwatch_run>
				case RESET :
				
				stopwatch_reset();
 8fa:	01 c0       	rjmp	.+2      	; 0x8fe <main+0x96>
 8fc:	7a d0       	rcall	.+244    	; 0x9f2 <stopwatch_reset>
				break;

			}
			if(get_BUTTON1())
 8fe:	f6 db       	rcall	.-2068   	; 0xec <get_BUTTON1>
 900:	89 2b       	or	r24, r25
 902:	21 f0       	breq	.+8      	; 0x90c <main+0xa4>
 904:	10 92 9e 01 	sts	0x019E, r1	; 0x80019e <mode+0x1>
			{
				
				mode = WATCH;
 908:	10 92 9d 01 	sts	0x019D, r1	; 0x80019d <mode>
 90c:	03 d1       	rcall	.+518    	; 0xb14 <pc_command_processing>
			}
			break;
		}
		
		pc_command_processing(); // pc에서 받는 command를 처리 fnuc 
 90e:	c1 d1       	rcall	.+898    	; 0xc92 <bt_command_processing>
 910:	c6 cf       	rjmp	.-116    	; 0x89e <main+0x36>

00000912 <inc_stopwatch_clock>:


// 1초에 한 번씩 Call을 한다.
void inc_stopwatch_clock(void)
{	
	count++; 
 912:	80 91 b9 01 	lds	r24, 0x01B9	; 0x8001b9 <count>
 916:	8f 5f       	subi	r24, 0xFF	; 255
 918:	80 93 b9 01 	sts	0x01B9, r24	; 0x8001b9 <count>
	if(count >= 100 )
 91c:	84 36       	cpi	r24, 0x64	; 100
 91e:	78 f1       	brcs	.+94     	; 0x97e <inc_stopwatch_clock+0x6c>
	{
		count = 0; 
 920:	10 92 b9 01 	sts	0x01B9, r1	; 0x8001b9 <count>
		
		stopwatch_sec++;
 924:	80 91 ba 01 	lds	r24, 0x01BA	; 0x8001ba <stopwatch_sec>
 928:	90 91 bb 01 	lds	r25, 0x01BB	; 0x8001bb <stopwatch_sec+0x1>
 92c:	01 96       	adiw	r24, 0x01	; 1
 92e:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <stopwatch_sec+0x1>
 932:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <stopwatch_sec>
		if(stopwatch_sec >= 60)
 936:	cc 97       	sbiw	r24, 0x3c	; 60
 938:	14 f1       	brlt	.+68     	; 0x97e <inc_stopwatch_clock+0x6c>
		{
			stopwatch_sec = 0; // 다음 초를 위해 CLEAR
 93a:	10 92 bb 01 	sts	0x01BB, r1	; 0x8001bb <stopwatch_sec+0x1>
 93e:	10 92 ba 01 	sts	0x01BA, r1	; 0x8001ba <stopwatch_sec>
			stopwatch_min++;
 942:	80 91 bc 01 	lds	r24, 0x01BC	; 0x8001bc <stopwatch_min>
 946:	90 91 bd 01 	lds	r25, 0x01BD	; 0x8001bd <stopwatch_min+0x1>
 94a:	01 96       	adiw	r24, 0x01	; 1
 94c:	90 93 bd 01 	sts	0x01BD, r25	; 0x8001bd <stopwatch_min+0x1>
 950:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <stopwatch_min>
			
			if(stopwatch_min >= 60)
 954:	cc 97       	sbiw	r24, 0x3c	; 60
 956:	9c f0       	brlt	.+38     	; 0x97e <inc_stopwatch_clock+0x6c>
			{
				stopwatch_min = 0;
 958:	10 92 bd 01 	sts	0x01BD, r1	; 0x8001bd <stopwatch_min+0x1>
 95c:	10 92 bc 01 	sts	0x01BC, r1	; 0x8001bc <stopwatch_min>
				stopwatch_hour++;
 960:	80 91 be 01 	lds	r24, 0x01BE	; 0x8001be <stopwatch_hour>
 964:	90 91 bf 01 	lds	r25, 0x01BF	; 0x8001bf <stopwatch_hour+0x1>
 968:	01 96       	adiw	r24, 0x01	; 1
 96a:	90 93 bf 01 	sts	0x01BF, r25	; 0x8001bf <stopwatch_hour+0x1>
 96e:	80 93 be 01 	sts	0x01BE, r24	; 0x8001be <stopwatch_hour>
				
				if(stopwatch_hour >=24)
 972:	48 97       	sbiw	r24, 0x18	; 24
 974:	24 f0       	brlt	.+8      	; 0x97e <inc_stopwatch_clock+0x6c>
				{
					stopwatch_hour = 0;
 976:	10 92 bf 01 	sts	0x01BF, r1	; 0x8001bf <stopwatch_hour+0x1>
 97a:	10 92 be 01 	sts	0x01BE, r1	; 0x8001be <stopwatch_hour>
					
				}
			}
		}
	}
	 stopwatchclock = (stopwatch_sec + stopwatch_min * 100 ); // 총 몇인지 나옴 
 97e:	80 91 bc 01 	lds	r24, 0x01BC	; 0x8001bc <stopwatch_min>
 982:	90 91 bd 01 	lds	r25, 0x01BD	; 0x8001bd <stopwatch_min+0x1>
 986:	44 e6       	ldi	r20, 0x64	; 100
 988:	48 9f       	mul	r20, r24
 98a:	90 01       	movw	r18, r0
 98c:	49 9f       	mul	r20, r25
 98e:	30 0d       	add	r19, r0
 990:	11 24       	eor	r1, r1
 992:	80 91 ba 01 	lds	r24, 0x01BA	; 0x8001ba <stopwatch_sec>
 996:	90 91 bb 01 	lds	r25, 0x01BB	; 0x8001bb <stopwatch_sec+0x1>
 99a:	82 0f       	add	r24, r18
 99c:	93 1f       	adc	r25, r19
 99e:	90 93 c1 01 	sts	0x01C1, r25	; 0x8001c1 <stopwatchclock+0x1>
 9a2:	80 93 c0 01 	sts	0x01C0, r24	; 0x8001c0 <stopwatchclock>
 9a6:	08 95       	ret

000009a8 <stopwatch_run>:


 
void stopwatch_run()
{
	set_fnd_data(stopwatchclock); // FND에 출력할 data가 넘어간다. 
 9a8:	80 91 c0 01 	lds	r24, 0x01C0	; 0x8001c0 <stopwatchclock>
 9ac:	90 91 c1 01 	lds	r25, 0x01C1	; 0x8001c1 <stopwatchclock+0x1>
 9b0:	2a dc       	rcall	.-1964   	; 0x206 <set_fnd_data>
	
	if (get_BUTTON2())
 9b2:	cb db       	rcall	.-2154   	; 0x14a <get_BUTTON2>
 9b4:	89 2b       	or	r24, r25
 9b6:	21 f0       	breq	.+8      	; 0x9c0 <stopwatch_run+0x18>
 9b8:	10 92 c3 01 	sts	0x01C3, r1	; 0x8001c3 <stopwatch_state+0x1>
	{
		stopwatch_state = STOP; 
 9bc:	10 92 c2 01 	sts	0x01C2, r1	; 0x8001c2 <stopwatch_state>
 9c0:	08 95       	ret

000009c2 <stopwatch_stop>:
 9c2:	80 91 c0 01 	lds	r24, 0x01C0	; 0x8001c0 <stopwatchclock>
	}
}

void stopwatch_stop()
{
	set_fnd_data(stopwatchclock); // FND에 출력할 data가 넘어간다.
 9c6:	90 91 c1 01 	lds	r25, 0x01C1	; 0x8001c1 <stopwatchclock+0x1>
 9ca:	1d dc       	rcall	.-1990   	; 0x206 <set_fnd_data>
	
	if (get_BUTTON2())
 9cc:	be db       	rcall	.-2180   	; 0x14a <get_BUTTON2>
 9ce:	89 2b       	or	r24, r25
 9d0:	31 f0       	breq	.+12     	; 0x9de <stopwatch_stop+0x1c>
 9d2:	81 e0       	ldi	r24, 0x01	; 1
	{
		stopwatch_state = RUN; 
 9d4:	90 e0       	ldi	r25, 0x00	; 0
 9d6:	90 93 c3 01 	sts	0x01C3, r25	; 0x8001c3 <stopwatch_state+0x1>
 9da:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <stopwatch_state>
		
	}
	if (get_BUTTON3())
 9de:	e4 db       	rcall	.-2104   	; 0x1a8 <get_BUTTON3>
 9e0:	89 2b       	or	r24, r25
 9e2:	31 f0       	breq	.+12     	; 0x9f0 <stopwatch_stop+0x2e>
 9e4:	82 e0       	ldi	r24, 0x02	; 2
	{
		stopwatch_state = RESET; 
 9e6:	90 e0       	ldi	r25, 0x00	; 0
 9e8:	90 93 c3 01 	sts	0x01C3, r25	; 0x8001c3 <stopwatch_state+0x1>
 9ec:	80 93 c2 01 	sts	0x01C2, r24	; 0x8001c2 <stopwatch_state>
 9f0:	08 95       	ret

000009f2 <stopwatch_reset>:
 9f2:	10 92 c1 01 	sts	0x01C1, r1	; 0x8001c1 <stopwatchclock+0x1>
	}
}

void stopwatch_reset()
{
	stopwatchclock = 0; 
 9f6:	10 92 c0 01 	sts	0x01C0, r1	; 0x8001c0 <stopwatchclock>
	stopwatch_state = 0;
 9fa:	10 92 c3 01 	sts	0x01C3, r1	; 0x8001c3 <stopwatch_state+0x1>
 9fe:	10 92 c2 01 	sts	0x01C2, r1	; 0x8001c2 <stopwatch_state>
	stopwatch_hour = 0;
 a02:	10 92 bf 01 	sts	0x01BF, r1	; 0x8001bf <stopwatch_hour+0x1>
 a06:	10 92 be 01 	sts	0x01BE, r1	; 0x8001be <stopwatch_hour>
	stopwatch_min = 0;
 a0a:	10 92 bd 01 	sts	0x01BD, r1	; 0x8001bd <stopwatch_min+0x1>
 a0e:	10 92 bc 01 	sts	0x01BC, r1	; 0x8001bc <stopwatch_min>
	stopwatch_sec = 0;
 a12:	10 92 bb 01 	sts	0x01BB, r1	; 0x8001bb <stopwatch_sec+0x1>
 a16:	10 92 ba 01 	sts	0x01BA, r1	; 0x8001ba <stopwatch_sec>
	count = 0;
 a1a:	10 92 b9 01 	sts	0x01B9, r1	; 0x8001b9 <count>
	
	set_fnd_data(stopwatchclock);
 a1e:	80 e0       	ldi	r24, 0x00	; 0
 a20:	90 e0       	ldi	r25, 0x00	; 0
 a22:	f1 db       	rcall	.-2078   	; 0x206 <set_fnd_data>
	stopwatch_state = STOP;
 a24:	10 92 c3 01 	sts	0x01C3, r1	; 0x8001c3 <stopwatch_state+0x1>
 a28:	10 92 c2 01 	sts	0x01C2, r1	; 0x8001c2 <stopwatch_state>
 a2c:	08 95       	ret

00000a2e <get_time_clock>:
	 *time=time_clock;			// call by ref 
	
}
void set_time_clock(TIME time) // *time 은 TIME의 주소를 갖는다.
{
	time_clock = time;		   // call by value
 a2e:	20 91 c4 01 	lds	r18, 0x01C4	; 0x8001c4 <time_clock>
 a32:	30 91 c5 01 	lds	r19, 0x01C5	; 0x8001c5 <time_clock+0x1>
 a36:	40 91 c6 01 	lds	r20, 0x01C6	; 0x8001c6 <time_clock+0x2>
 a3a:	fc 01       	movw	r30, r24
 a3c:	20 83       	st	Z, r18
 a3e:	31 83       	std	Z+1, r19	; 0x01
 a40:	42 83       	std	Z+2, r20	; 0x02
 a42:	08 95       	ret

00000a44 <inc_time_sec>:
	
}
// 1초에 한 번씩 Call을 한다. 
void inc_time_sec(void)
{
	time_clock.sec++;
 a44:	e4 ec       	ldi	r30, 0xC4	; 196
 a46:	f1 e0       	ldi	r31, 0x01	; 1
 a48:	82 81       	ldd	r24, Z+2	; 0x02
 a4a:	8f 5f       	subi	r24, 0xFF	; 255
 a4c:	82 83       	std	Z+2, r24	; 0x02
	if(time_clock.sec >= 60)
 a4e:	8c 33       	cpi	r24, 0x3C	; 60
 a50:	70 f0       	brcs	.+28     	; 0xa6e <inc_time_sec+0x2a>
	{
		time_clock.sec = 0; // 다음 초를 위해 CLEAR
 a52:	12 82       	std	Z+2, r1	; 0x02
		time_clock.min++; 
 a54:	81 81       	ldd	r24, Z+1	; 0x01
 a56:	8f 5f       	subi	r24, 0xFF	; 255
 a58:	81 83       	std	Z+1, r24	; 0x01
		
		if(time_clock.min >= 60)
 a5a:	8c 33       	cpi	r24, 0x3C	; 60
 a5c:	40 f0       	brcs	.+16     	; 0xa6e <inc_time_sec+0x2a>
		{
			time_clock.min = 0;
 a5e:	11 82       	std	Z+1, r1	; 0x01
			time_clock.hour++; 
 a60:	80 81       	ld	r24, Z
 a62:	8f 5f       	subi	r24, 0xFF	; 255
 a64:	80 83       	st	Z, r24
			
			if(time_clock.hour >=24)
 a66:	88 31       	cpi	r24, 0x18	; 24
 a68:	10 f0       	brcs	.+4      	; 0xa6e <inc_time_sec+0x2a>
			{
				time_clock.hour = 0;
 a6a:	10 92 c4 01 	sts	0x01C4, r1	; 0x8001c4 <time_clock>
 a6e:	08 95       	ret

00000a70 <__vector_18>:




ISR(USART0_RX_vect)
{
 a70:	1f 92       	push	r1
 a72:	0f 92       	push	r0
 a74:	0f b6       	in	r0, 0x3f	; 63
 a76:	0f 92       	push	r0
 a78:	11 24       	eor	r1, r1
 a7a:	0b b6       	in	r0, 0x3b	; 59
 a7c:	0f 92       	push	r0
 a7e:	2f 93       	push	r18
 a80:	3f 93       	push	r19
 a82:	4f 93       	push	r20
 a84:	5f 93       	push	r21
 a86:	8f 93       	push	r24
 a88:	ef 93       	push	r30
 a8a:	ff 93       	push	r31
	unsigned char data;	
	
	data = UDR0; // uart0의 h/w register (URD0)로 1byte를 읽어 들인다. 
 a8c:	8c b1       	in	r24, 0x0c	; 12
	
	if (data == '\r' || data == '\n')// 문장의 끝인 경우 
 a8e:	8d 30       	cpi	r24, 0x0D	; 13
 a90:	11 f0       	breq	.+4      	; 0xa96 <__vector_18+0x26>
 a92:	8a 30       	cpi	r24, 0x0A	; 10
 a94:	79 f4       	brne	.+30     	; 0xab4 <__vector_18+0x44>
	{
		rx_buffer[i] = '\0'; // 문장의 끝을 알려줌 (NULL)
 a96:	e0 91 c7 01 	lds	r30, 0x01C7	; 0x8001c7 <i>
 a9a:	f0 91 c8 01 	lds	r31, 0x01C8	; 0x8001c8 <i+0x1>
 a9e:	e1 5f       	subi	r30, 0xF1	; 241
 aa0:	fd 4f       	sbci	r31, 0xFD	; 253
 aa2:	10 82       	st	Z, r1
		i = 0;				 // 개선점 : circular queue (환형큐)로 개선을 해야한다. 
 aa4:	10 92 c8 01 	sts	0x01C8, r1	; 0x8001c8 <i+0x1>
 aa8:	10 92 c7 01 	sts	0x01C7, r1	; 0x8001c7 <i>
							 // 이렇게 프로그램을 작성하면, 새로운 메세지가 왔을 때 덮어 쓴다. 
							 
		rx_ready_flag = 1;	 // 완전한 문장이 들어 왔을 때 1로 set 된다. 
 aac:	81 e0       	ldi	r24, 0x01	; 1
 aae:	80 93 c9 01 	sts	0x01C9, r24	; 0x8001c9 <rx_ready_flag>
 ab2:	0f c0       	rjmp	.+30     	; 0xad2 <__vector_18+0x62>
	} 
	else
	{
		rx_buffer[i++] = data; // 1. rx_buffer[i] = data  / 2. i++ 
 ab4:	20 91 c7 01 	lds	r18, 0x01C7	; 0x8001c7 <i>
 ab8:	30 91 c8 01 	lds	r19, 0x01C8	; 0x8001c8 <i+0x1>
 abc:	a9 01       	movw	r20, r18
 abe:	4f 5f       	subi	r20, 0xFF	; 255
 ac0:	5f 4f       	sbci	r21, 0xFF	; 255
 ac2:	50 93 c8 01 	sts	0x01C8, r21	; 0x8001c8 <i+0x1>
 ac6:	40 93 c7 01 	sts	0x01C7, r20	; 0x8001c7 <i>
 aca:	f9 01       	movw	r30, r18
 acc:	e1 5f       	subi	r30, 0xF1	; 241
 ace:	fd 4f       	sbci	r31, 0xFD	; 253
 ad0:	80 83       	st	Z, r24
	}
}
 ad2:	ff 91       	pop	r31
 ad4:	ef 91       	pop	r30
 ad6:	8f 91       	pop	r24
 ad8:	5f 91       	pop	r21
 ada:	4f 91       	pop	r20
 adc:	3f 91       	pop	r19
 ade:	2f 91       	pop	r18
 ae0:	0f 90       	pop	r0
 ae2:	0b be       	out	0x3b, r0	; 59
 ae4:	0f 90       	pop	r0
 ae6:	0f be       	out	0x3f, r0	; 63
 ae8:	0f 90       	pop	r0
 aea:	1f 90       	pop	r1
 aec:	18 95       	reti

00000aee <init_uart0>:

void init_uart0()
{
	UBRR0H = 0x00; 
 aee:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
	UBRR0L = 207; // 9600bps 
 af2:	8f ec       	ldi	r24, 0xCF	; 207
 af4:	89 b9       	out	0x09, r24	; 9
	
	UCSR0A |= (1 << U2X0); // 2배속 통신
 af6:	8b b1       	in	r24, 0x0b	; 11
 af8:	82 60       	ori	r24, 0x02	; 2
 afa:	8b b9       	out	0x0b, r24	; 11
	UCSR0C |= 0x06; // ASYNC(비동기) data 8 bit, none parity 
 afc:	e5 e9       	ldi	r30, 0x95	; 149
 afe:	f0 e0       	ldi	r31, 0x00	; 0
 b00:	80 81       	ld	r24, Z
 b02:	86 60       	ori	r24, 0x06	; 6
 b04:	80 83       	st	Z, r24
	
	// RXEN0 : UART0로 부터 수신이 가능 하도록 설정 
	// TXEN0 : UART0로 부터 송신이 가능 하도록 설정
	// RXCIE0 : UART0로 부터 1 byte가 들어 오면 RX(수신) Interrupt를 발생시켜라
	
	UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0);  // 송수신 활성 및 수신 시 Interrupt (alram)발생 
 b06:	88 e9       	ldi	r24, 0x98	; 152
 b08:	8a b9       	out	0x0a, r24	; 10
 b0a:	08 95       	ret

00000b0c <UART0_transmit>:
	// 19번 인터럽트 발생 
}
// UART0 로 1 byte를 보내는 함수 
void UART0_transmit(uint8_t data) 
{
	while (!(UCSR0A & (1 << UDRE0))) // data가 전송 중이면 data가 다 전송이 될 때 까지 기다린다. 
 b0c:	5d 9b       	sbis	0x0b, 5	; 11
 b0e:	fe cf       	rjmp	.-4      	; 0xb0c <UART0_transmit>
		;  // No Operation (아무 action도 취하지 않는다.)
	UDR0 = data; // HW 전송 register에 data를 쏴준다. 
 b10:	8c b9       	out	0x0c, r24	; 12
 b12:	08 95       	ret

00000b14 <pc_command_processing>:
extern int led_command; // flag setting 


void pc_command_processing()
{
	if(rx_ready_flag)	
 b14:	80 91 c9 01 	lds	r24, 0x01C9	; 0x8001c9 <rx_ready_flag>
 b18:	88 23       	and	r24, r24
 b1a:	09 f4       	brne	.+2      	; 0xb1e <pc_command_processing+0xa>
 b1c:	91 c0       	rjmp	.+290    	; 0xc40 <pc_command_processing+0x12c>
	{
		rx_ready_flag = 0; // 0으로 변환하여 다음 메세지를 받을 수 있도록 초기화 
 b1e:	10 92 c9 01 	sts	0x01C9, r1	; 0x8001c9 <rx_ready_flag>
		printf("%s\n", rx_buffer);
 b22:	8f e0       	ldi	r24, 0x0F	; 15
 b24:	92 e0       	ldi	r25, 0x02	; 2
 b26:	df d1       	rcall	.+958    	; 0xee6 <puts>
		
		if(strncmp(rx_buffer, "ledallon" ,strlen("ledallon")-1 )== 0) // 내용이 같으면 0이나옴 // -1은 NULL 문자 제거를 위함 ('\n')
 b28:	47 e0       	ldi	r20, 0x07	; 7
 b2a:	50 e0       	ldi	r21, 0x00	; 0
 b2c:	68 e1       	ldi	r22, 0x18	; 24
 b2e:	71 e0       	ldi	r23, 0x01	; 1
 b30:	8f e0       	ldi	r24, 0x0F	; 15
 b32:	92 e0       	ldi	r25, 0x02	; 2
 b34:	ca d1       	rcall	.+916    	; 0xeca <strncmp>
 b36:	89 2b       	or	r24, r25
 b38:	11 f4       	brne	.+4      	; 0xb3e <pc_command_processing+0x2a>
			PORTA = 0xff;
 b3a:	8f ef       	ldi	r24, 0xFF	; 255
 b3c:	8b bb       	out	0x1b, r24	; 27
		
		if(strncmp(rx_buffer, "ledalloff" ,strlen("ledalloff")-1 )== 0)
 b3e:	48 e0       	ldi	r20, 0x08	; 8
 b40:	50 e0       	ldi	r21, 0x00	; 0
 b42:	61 e2       	ldi	r22, 0x21	; 33
 b44:	71 e0       	ldi	r23, 0x01	; 1
 b46:	8f e0       	ldi	r24, 0x0F	; 15
 b48:	92 e0       	ldi	r25, 0x02	; 2
 b4a:	bf d1       	rcall	.+894    	; 0xeca <strncmp>
 b4c:	89 2b       	or	r24, r25
 b4e:	09 f4       	brne	.+2      	; 0xb52 <pc_command_processing+0x3e>
			PORTA = 0x00;
 b50:	1b ba       	out	0x1b, r1	; 27
			
		if(strncmp(rx_buffer, "reset" ,strlen("reset")-1 )== 0)
 b52:	44 e0       	ldi	r20, 0x04	; 4
 b54:	50 e0       	ldi	r21, 0x00	; 0
 b56:	6b e2       	ldi	r22, 0x2B	; 43
 b58:	71 e0       	ldi	r23, 0x01	; 1
 b5a:	8f e0       	ldi	r24, 0x0F	; 15
 b5c:	92 e0       	ldi	r25, 0x02	; 2
 b5e:	b5 d1       	rcall	.+874    	; 0xeca <strncmp>
 b60:	89 2b       	or	r24, r25
 b62:	09 f4       	brne	.+2      	; 0xb66 <pc_command_processing+0x52>
			PORTA = 0x00;
 b64:	1b ba       	out	0x1b, r1	; 27
			led_command = 0;
 b66:	10 92 9a 01 	sts	0x019A, r1	; 0x80019a <led_command+0x1>
 b6a:	10 92 99 01 	sts	0x0199, r1	; 0x800199 <led_command>
		
		if(strncmp(rx_buffer, "ledalltoggle" ,strlen("ledalltoggle")-1 )== 0) // state를 확인 할 command flag가 필요 
 b6e:	4b e0       	ldi	r20, 0x0B	; 11
 b70:	50 e0       	ldi	r21, 0x00	; 0
 b72:	61 e3       	ldi	r22, 0x31	; 49
 b74:	71 e0       	ldi	r23, 0x01	; 1
 b76:	8f e0       	ldi	r24, 0x0F	; 15
 b78:	92 e0       	ldi	r25, 0x02	; 2
 b7a:	a7 d1       	rcall	.+846    	; 0xeca <strncmp>
 b7c:	89 2b       	or	r24, r25
 b7e:	31 f4       	brne	.+12     	; 0xb8c <pc_command_processing+0x78>

			led_command = 1; 
 b80:	81 e0       	ldi	r24, 0x01	; 1
 b82:	90 e0       	ldi	r25, 0x00	; 0
 b84:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <led_command+0x1>
 b88:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <led_command>
		
		if(strncmp(rx_buffer, "shiftleftledon" ,strlen("shiftleftledon")-1 )== 0) 
 b8c:	4d e0       	ldi	r20, 0x0D	; 13
 b8e:	50 e0       	ldi	r21, 0x00	; 0
 b90:	6e e3       	ldi	r22, 0x3E	; 62
 b92:	71 e0       	ldi	r23, 0x01	; 1
 b94:	8f e0       	ldi	r24, 0x0F	; 15
 b96:	92 e0       	ldi	r25, 0x02	; 2
 b98:	98 d1       	rcall	.+816    	; 0xeca <strncmp>
 b9a:	89 2b       	or	r24, r25
 b9c:	31 f4       	brne	.+12     	; 0xbaa <pc_command_processing+0x96>
			led_command = 2;
 b9e:	82 e0       	ldi	r24, 0x02	; 2
 ba0:	90 e0       	ldi	r25, 0x00	; 0
 ba2:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <led_command+0x1>
 ba6:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <led_command>
		
		if(strncmp(rx_buffer, "shiftrightledon" ,strlen("shiftrightledon")-1 )== 0) 
 baa:	4e e0       	ldi	r20, 0x0E	; 14
 bac:	50 e0       	ldi	r21, 0x00	; 0
 bae:	6d e4       	ldi	r22, 0x4D	; 77
 bb0:	71 e0       	ldi	r23, 0x01	; 1
 bb2:	8f e0       	ldi	r24, 0x0F	; 15
 bb4:	92 e0       	ldi	r25, 0x02	; 2
 bb6:	89 d1       	rcall	.+786    	; 0xeca <strncmp>
 bb8:	89 2b       	or	r24, r25
 bba:	31 f4       	brne	.+12     	; 0xbc8 <pc_command_processing+0xb4>
			led_command = 3;
 bbc:	83 e0       	ldi	r24, 0x03	; 3
 bbe:	90 e0       	ldi	r25, 0x00	; 0
 bc0:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <led_command+0x1>
 bc4:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <led_command>
		
		if(strncmp(rx_buffer, "shiftleftholdledon" ,strlen("shiftleftholdledon")-1 )== 0) 
 bc8:	41 e1       	ldi	r20, 0x11	; 17
 bca:	50 e0       	ldi	r21, 0x00	; 0
 bcc:	6d e5       	ldi	r22, 0x5D	; 93
 bce:	71 e0       	ldi	r23, 0x01	; 1
 bd0:	8f e0       	ldi	r24, 0x0F	; 15
 bd2:	92 e0       	ldi	r25, 0x02	; 2
 bd4:	7a d1       	rcall	.+756    	; 0xeca <strncmp>
 bd6:	89 2b       	or	r24, r25
 bd8:	31 f4       	brne	.+12     	; 0xbe6 <pc_command_processing+0xd2>
			led_command = 4;
 bda:	84 e0       	ldi	r24, 0x04	; 4
 bdc:	90 e0       	ldi	r25, 0x00	; 0
 bde:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <led_command+0x1>
 be2:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <led_command>
		
		if(strncmp(rx_buffer, "shiftrightholdledon" ,strlen("shiftrightholdledon")-1 )== 0) 
 be6:	42 e1       	ldi	r20, 0x12	; 18
 be8:	50 e0       	ldi	r21, 0x00	; 0
 bea:	60 e7       	ldi	r22, 0x70	; 112
 bec:	71 e0       	ldi	r23, 0x01	; 1
 bee:	8f e0       	ldi	r24, 0x0F	; 15
 bf0:	92 e0       	ldi	r25, 0x02	; 2
 bf2:	6b d1       	rcall	.+726    	; 0xeca <strncmp>
 bf4:	89 2b       	or	r24, r25
 bf6:	31 f4       	brne	.+12     	; 0xc04 <pc_command_processing+0xf0>
			led_command = 5;
 bf8:	85 e0       	ldi	r24, 0x05	; 5
 bfa:	90 e0       	ldi	r25, 0x00	; 0
 bfc:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <led_command+0x1>
 c00:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <led_command>
		
		if(strncmp(rx_buffer, "f_off" ,strlen("f_off")-1 )== 0) 
 c04:	44 e0       	ldi	r20, 0x04	; 4
 c06:	50 e0       	ldi	r21, 0x00	; 0
 c08:	64 e8       	ldi	r22, 0x84	; 132
 c0a:	71 e0       	ldi	r23, 0x01	; 1
 c0c:	8f e0       	ldi	r24, 0x0F	; 15
 c0e:	92 e0       	ldi	r25, 0x02	; 2
 c10:	5c d1       	rcall	.+696    	; 0xeca <strncmp>
 c12:	89 2b       	or	r24, r25
 c14:	31 f4       	brne	.+12     	; 0xc22 <pc_command_processing+0x10e>
			led_command = 6;
 c16:	86 e0       	ldi	r24, 0x06	; 6
 c18:	90 e0       	ldi	r25, 0x00	; 0
 c1a:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <led_command+0x1>
 c1e:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <led_command>
		
		if(strncmp(rx_buffer, "flower_on" ,strlen("flower_on")-1 )== 0) 
 c22:	48 e0       	ldi	r20, 0x08	; 8
 c24:	50 e0       	ldi	r21, 0x00	; 0
 c26:	6a e8       	ldi	r22, 0x8A	; 138
 c28:	71 e0       	ldi	r23, 0x01	; 1
 c2a:	8f e0       	ldi	r24, 0x0F	; 15
 c2c:	92 e0       	ldi	r25, 0x02	; 2
 c2e:	4d d1       	rcall	.+666    	; 0xeca <strncmp>
 c30:	89 2b       	or	r24, r25
 c32:	31 f4       	brne	.+12     	; 0xc40 <pc_command_processing+0x12c>
			led_command = 7;
 c34:	87 e0       	ldi	r24, 0x07	; 7
 c36:	90 e0       	ldi	r25, 0x00	; 0
 c38:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <led_command+0x1>
 c3c:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <led_command>
		
		
		 
		
	}
	 switch(led_command)
 c40:	e0 91 99 01 	lds	r30, 0x0199	; 0x800199 <led_command>
 c44:	f0 91 9a 01 	lds	r31, 0x019A	; 0x80019a <led_command+0x1>
 c48:	31 97       	sbiw	r30, 0x01	; 1
 c4a:	e7 30       	cpi	r30, 0x07	; 7
 c4c:	f1 05       	cpc	r31, r1
	 {
		
		 
		 case 1:
		 ledalltoggle();
 c4e:	80 f4       	brcc	.+32     	; 0xc70 <pc_command_processing+0x15c>
		 
		 break;
 c50:	ea 5b       	subi	r30, 0xBA	; 186
		 
		 case 2:
		 shiftleftledon();
 c52:	ff 4f       	sbci	r31, 0xFF	; 255
 c54:	22 c1       	rjmp	.+580    	; 0xe9a <__tablejump2__>
		 
		 break;
 c56:	ce cb       	rjmp	.-2148   	; 0x3f4 <ledalltoggle>
		 
		 case 3:
		 shiftrightledon();
 c58:	08 95       	ret
 c5a:	dd cb       	rjmp	.-2118   	; 0x416 <shiftleftledon>
		 break;
 c5c:	08 95       	ret
		 
		 case 4:
		 shiftleftholdledon();
 c5e:	01 cc       	rjmp	.-2046   	; 0x462 <shiftrightledon>
 c60:	08 95       	ret
		 break;
 c62:	25 cc       	rjmp	.-1974   	; 0x4ae <shiftleftholdledon>
		 
		 case 5:
		 shiftrightholdledon();
 c64:	08 95       	ret
 c66:	48 cc       	rjmp	.-1904   	; 0x4f8 <shiftrightholdledon>
		 break;
 c68:	08 95       	ret
		 
		 case 6:
		 f_off();
 c6a:	6b cc       	rjmp	.-1834   	; 0x542 <f_off>
 c6c:	08 95       	ret
		 break;
 c6e:	99 cc       	rjmp	.-1742   	; 0x5a2 <flower_on>
		 
		 case 7:
		 flower_on();
 c70:	08 95       	ret

00000c72 <init_UART1>:
 c72:	ea e9       	ldi	r30, 0x9A	; 154
 c74:	f0 e0       	ldi	r31, 0x00	; 0
extern uint32_t led_command; 

ISR(USART1_RX_vect)
{
	UART1_ISR_Receive();		 // 1char가 들어올 떄마다 call 
}
 c76:	80 81       	ld	r24, Z
 c78:	88 69       	ori	r24, 0x98	; 152
 c7a:	80 83       	st	Z, r24
 c7c:	eb e9       	ldi	r30, 0x9B	; 155
 c7e:	f0 e0       	ldi	r31, 0x00	; 0
 c80:	80 81       	ld	r24, Z
 c82:	82 60       	ori	r24, 0x02	; 2
 c84:	80 83       	st	Z, r24
 c86:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
 c8a:	8f ec       	ldi	r24, 0xCF	; 207
 c8c:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
 c90:	08 95       	ret

00000c92 <bt_command_processing>:
	}
}

void bt_command_processing()
{
	if(rx1ReadyFlag)
 c92:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <rx1ReadyFlag>
 c96:	88 23       	and	r24, r24
 c98:	09 f4       	brne	.+2      	; 0xc9c <bt_command_processing+0xa>
 c9a:	bf c0       	rjmp	.+382    	; 0xe1a <bt_command_processing+0x188>
	{
		rx1ReadyFlag = 0; // 0으로 변환하여 다음 메세지를 받을 수 있도록 초기화
 c9c:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <rx1ReadyFlag>
		printf("%s\n", rx1String);
 ca0:	8b ec       	ldi	r24, 0xCB	; 203
 ca2:	91 e0       	ldi	r25, 0x01	; 1
 ca4:	20 d1       	rcall	.+576    	; 0xee6 <puts>
		
		if(strncmp(rx1String, "ledallon" ,strlen("ledallon")-1 )== 0) // 내용이 같으면 0이나옴 // -1은 NULL 문자 제거를 위함 ('\n')
 ca6:	47 e0       	ldi	r20, 0x07	; 7
 ca8:	50 e0       	ldi	r21, 0x00	; 0
 caa:	68 e1       	ldi	r22, 0x18	; 24
 cac:	71 e0       	ldi	r23, 0x01	; 1
 cae:	8b ec       	ldi	r24, 0xCB	; 203
 cb0:	91 e0       	ldi	r25, 0x01	; 1
 cb2:	0b d1       	rcall	.+534    	; 0xeca <strncmp>
 cb4:	89 2b       	or	r24, r25
 cb6:	11 f4       	brne	.+4      	; 0xcbc <bt_command_processing+0x2a>
		PORTA = 0xff;
 cb8:	8f ef       	ldi	r24, 0xFF	; 255
 cba:	8b bb       	out	0x1b, r24	; 27
		
		if(strncmp(rx1String, "ledalloff" ,strlen("ledalloff")-1 )== 0)
 cbc:	48 e0       	ldi	r20, 0x08	; 8
 cbe:	50 e0       	ldi	r21, 0x00	; 0
 cc0:	61 e2       	ldi	r22, 0x21	; 33
 cc2:	71 e0       	ldi	r23, 0x01	; 1
 cc4:	8b ec       	ldi	r24, 0xCB	; 203
 cc6:	91 e0       	ldi	r25, 0x01	; 1
 cc8:	00 d1       	rcall	.+512    	; 0xeca <strncmp>
 cca:	89 2b       	or	r24, r25
 ccc:	09 f4       	brne	.+2      	; 0xcd0 <bt_command_processing+0x3e>
		PORTA = 0x00;
 cce:	1b ba       	out	0x1b, r1	; 27
		
		if(strncmp(rx1String, "reset" ,strlen("reset")-1 )== 0)
 cd0:	44 e0       	ldi	r20, 0x04	; 4
 cd2:	50 e0       	ldi	r21, 0x00	; 0
 cd4:	6b e2       	ldi	r22, 0x2B	; 43
 cd6:	71 e0       	ldi	r23, 0x01	; 1
 cd8:	8b ec       	ldi	r24, 0xCB	; 203
 cda:	91 e0       	ldi	r25, 0x01	; 1
 cdc:	f6 d0       	rcall	.+492    	; 0xeca <strncmp>
 cde:	89 2b       	or	r24, r25
 ce0:	09 f4       	brne	.+2      	; 0xce4 <bt_command_processing+0x52>
		PORTA = 0x00;
 ce2:	1b ba       	out	0x1b, r1	; 27
		led_command = 0;
 ce4:	10 92 99 01 	sts	0x0199, r1	; 0x800199 <led_command>
 ce8:	10 92 9a 01 	sts	0x019A, r1	; 0x80019a <led_command+0x1>
 cec:	10 92 9b 01 	sts	0x019B, r1	; 0x80019b <led_command+0x2>
 cf0:	10 92 9c 01 	sts	0x019C, r1	; 0x80019c <led_command+0x3>
		
		if(strncmp(rx1String, "ledalltoggle" ,strlen("ledalltoggle")-1 )== 0) // state를 확인 할 command flag가 필요
 cf4:	4b e0       	ldi	r20, 0x0B	; 11
 cf6:	50 e0       	ldi	r21, 0x00	; 0
 cf8:	61 e3       	ldi	r22, 0x31	; 49
 cfa:	71 e0       	ldi	r23, 0x01	; 1
 cfc:	8b ec       	ldi	r24, 0xCB	; 203
 cfe:	91 e0       	ldi	r25, 0x01	; 1
 d00:	e4 d0       	rcall	.+456    	; 0xeca <strncmp>
 d02:	89 2b       	or	r24, r25
 d04:	61 f4       	brne	.+24     	; 0xd1e <bt_command_processing+0x8c>

		led_command = 1;
 d06:	81 e0       	ldi	r24, 0x01	; 1
 d08:	90 e0       	ldi	r25, 0x00	; 0
 d0a:	a0 e0       	ldi	r26, 0x00	; 0
 d0c:	b0 e0       	ldi	r27, 0x00	; 0
 d0e:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <led_command>
 d12:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <led_command+0x1>
 d16:	a0 93 9b 01 	sts	0x019B, r26	; 0x80019b <led_command+0x2>
 d1a:	b0 93 9c 01 	sts	0x019C, r27	; 0x80019c <led_command+0x3>
		
		if(strncmp(rx1String, "shiftleftledon" ,strlen("shiftleftledon")-1 )== 0)
 d1e:	4d e0       	ldi	r20, 0x0D	; 13
 d20:	50 e0       	ldi	r21, 0x00	; 0
 d22:	6e e3       	ldi	r22, 0x3E	; 62
 d24:	71 e0       	ldi	r23, 0x01	; 1
 d26:	8b ec       	ldi	r24, 0xCB	; 203
 d28:	91 e0       	ldi	r25, 0x01	; 1
 d2a:	cf d0       	rcall	.+414    	; 0xeca <strncmp>
 d2c:	89 2b       	or	r24, r25
 d2e:	61 f4       	brne	.+24     	; 0xd48 <bt_command_processing+0xb6>
		led_command = 2;
 d30:	82 e0       	ldi	r24, 0x02	; 2
 d32:	90 e0       	ldi	r25, 0x00	; 0
 d34:	a0 e0       	ldi	r26, 0x00	; 0
 d36:	b0 e0       	ldi	r27, 0x00	; 0
 d38:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <led_command>
 d3c:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <led_command+0x1>
 d40:	a0 93 9b 01 	sts	0x019B, r26	; 0x80019b <led_command+0x2>
 d44:	b0 93 9c 01 	sts	0x019C, r27	; 0x80019c <led_command+0x3>
		
		if(strncmp(rx1String, "shiftrightledon" ,strlen("shiftrightledon")-1 )== 0)
 d48:	4e e0       	ldi	r20, 0x0E	; 14
 d4a:	50 e0       	ldi	r21, 0x00	; 0
 d4c:	6d e4       	ldi	r22, 0x4D	; 77
 d4e:	71 e0       	ldi	r23, 0x01	; 1
 d50:	8b ec       	ldi	r24, 0xCB	; 203
 d52:	91 e0       	ldi	r25, 0x01	; 1
 d54:	ba d0       	rcall	.+372    	; 0xeca <strncmp>
 d56:	89 2b       	or	r24, r25
 d58:	61 f4       	brne	.+24     	; 0xd72 <bt_command_processing+0xe0>
		led_command = 3;
 d5a:	83 e0       	ldi	r24, 0x03	; 3
 d5c:	90 e0       	ldi	r25, 0x00	; 0
 d5e:	a0 e0       	ldi	r26, 0x00	; 0
 d60:	b0 e0       	ldi	r27, 0x00	; 0
 d62:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <led_command>
 d66:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <led_command+0x1>
 d6a:	a0 93 9b 01 	sts	0x019B, r26	; 0x80019b <led_command+0x2>
 d6e:	b0 93 9c 01 	sts	0x019C, r27	; 0x80019c <led_command+0x3>
		
		if(strncmp(rx1String, "shiftleftholdledon" ,strlen("shiftleftholdledon")-1 )== 0)
 d72:	41 e1       	ldi	r20, 0x11	; 17
 d74:	50 e0       	ldi	r21, 0x00	; 0
 d76:	6d e5       	ldi	r22, 0x5D	; 93
 d78:	71 e0       	ldi	r23, 0x01	; 1
 d7a:	8b ec       	ldi	r24, 0xCB	; 203
 d7c:	91 e0       	ldi	r25, 0x01	; 1
 d7e:	a5 d0       	rcall	.+330    	; 0xeca <strncmp>
 d80:	89 2b       	or	r24, r25
 d82:	61 f4       	brne	.+24     	; 0xd9c <bt_command_processing+0x10a>
		led_command = 4;
 d84:	84 e0       	ldi	r24, 0x04	; 4
 d86:	90 e0       	ldi	r25, 0x00	; 0
 d88:	a0 e0       	ldi	r26, 0x00	; 0
 d8a:	b0 e0       	ldi	r27, 0x00	; 0
 d8c:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <led_command>
 d90:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <led_command+0x1>
 d94:	a0 93 9b 01 	sts	0x019B, r26	; 0x80019b <led_command+0x2>
 d98:	b0 93 9c 01 	sts	0x019C, r27	; 0x80019c <led_command+0x3>
		
		if(strncmp(rx1String, "shiftrightholdledon" ,strlen("shiftrightholdledon")-1 )== 0)
 d9c:	42 e1       	ldi	r20, 0x12	; 18
 d9e:	50 e0       	ldi	r21, 0x00	; 0
 da0:	60 e7       	ldi	r22, 0x70	; 112
 da2:	71 e0       	ldi	r23, 0x01	; 1
 da4:	8b ec       	ldi	r24, 0xCB	; 203
 da6:	91 e0       	ldi	r25, 0x01	; 1
 da8:	90 d0       	rcall	.+288    	; 0xeca <strncmp>
 daa:	89 2b       	or	r24, r25
 dac:	61 f4       	brne	.+24     	; 0xdc6 <bt_command_processing+0x134>
		led_command = 5;
 dae:	85 e0       	ldi	r24, 0x05	; 5
 db0:	90 e0       	ldi	r25, 0x00	; 0
 db2:	a0 e0       	ldi	r26, 0x00	; 0
 db4:	b0 e0       	ldi	r27, 0x00	; 0
 db6:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <led_command>
 dba:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <led_command+0x1>
 dbe:	a0 93 9b 01 	sts	0x019B, r26	; 0x80019b <led_command+0x2>
 dc2:	b0 93 9c 01 	sts	0x019C, r27	; 0x80019c <led_command+0x3>
		
		if(strncmp(rx1String, "f_off" ,strlen("f_off")-1 )== 0)
 dc6:	44 e0       	ldi	r20, 0x04	; 4
 dc8:	50 e0       	ldi	r21, 0x00	; 0
 dca:	64 e8       	ldi	r22, 0x84	; 132
 dcc:	71 e0       	ldi	r23, 0x01	; 1
 dce:	8b ec       	ldi	r24, 0xCB	; 203
 dd0:	91 e0       	ldi	r25, 0x01	; 1
 dd2:	7b d0       	rcall	.+246    	; 0xeca <strncmp>
 dd4:	89 2b       	or	r24, r25
 dd6:	61 f4       	brne	.+24     	; 0xdf0 <bt_command_processing+0x15e>
		led_command = 6;
 dd8:	86 e0       	ldi	r24, 0x06	; 6
 dda:	90 e0       	ldi	r25, 0x00	; 0
 ddc:	a0 e0       	ldi	r26, 0x00	; 0
 dde:	b0 e0       	ldi	r27, 0x00	; 0
 de0:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <led_command>
 de4:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <led_command+0x1>
 de8:	a0 93 9b 01 	sts	0x019B, r26	; 0x80019b <led_command+0x2>
 dec:	b0 93 9c 01 	sts	0x019C, r27	; 0x80019c <led_command+0x3>
		
		if(strncmp(rx1String, "flower_on" ,strlen("flower_on")-1 )== 0)
 df0:	48 e0       	ldi	r20, 0x08	; 8
 df2:	50 e0       	ldi	r21, 0x00	; 0
 df4:	6a e8       	ldi	r22, 0x8A	; 138
 df6:	71 e0       	ldi	r23, 0x01	; 1
 df8:	8b ec       	ldi	r24, 0xCB	; 203
 dfa:	91 e0       	ldi	r25, 0x01	; 1
 dfc:	66 d0       	rcall	.+204    	; 0xeca <strncmp>
 dfe:	89 2b       	or	r24, r25
 e00:	61 f4       	brne	.+24     	; 0xe1a <bt_command_processing+0x188>
		led_command = 7;	
 e02:	87 e0       	ldi	r24, 0x07	; 7
 e04:	90 e0       	ldi	r25, 0x00	; 0
 e06:	a0 e0       	ldi	r26, 0x00	; 0
 e08:	b0 e0       	ldi	r27, 0x00	; 0
 e0a:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <led_command>
 e0e:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <led_command+0x1>
 e12:	a0 93 9b 01 	sts	0x019B, r26	; 0x80019b <led_command+0x2>
 e16:	b0 93 9c 01 	sts	0x019C, r27	; 0x80019c <led_command+0x3>
	}
	switch(led_command)
 e1a:	80 91 99 01 	lds	r24, 0x0199	; 0x800199 <led_command>
 e1e:	90 91 9a 01 	lds	r25, 0x019A	; 0x80019a <led_command+0x1>
 e22:	a0 91 9b 01 	lds	r26, 0x019B	; 0x80019b <led_command+0x2>
 e26:	b0 91 9c 01 	lds	r27, 0x019C	; 0x80019c <led_command+0x3>
 e2a:	fc 01       	movw	r30, r24
 e2c:	31 97       	sbiw	r30, 0x01	; 1
 e2e:	e7 30       	cpi	r30, 0x07	; 7
 e30:	f1 05       	cpc	r31, r1
	{
		
		
		case 1:
		ledalltoggle();
 e32:	80 f4       	brcc	.+32     	; 0xe54 <bt_command_processing+0x1c2>
		
		break;
 e34:	e3 5b       	subi	r30, 0xB3	; 179
		
		case 2:
		shiftleftledon();
 e36:	ff 4f       	sbci	r31, 0xFF	; 255
 e38:	30 c0       	rjmp	.+96     	; 0xe9a <__tablejump2__>
		
		break;
 e3a:	dc ca       	rjmp	.-2632   	; 0x3f4 <ledalltoggle>
		
		case 3:
		shiftrightledon();
 e3c:	08 95       	ret
 e3e:	eb ca       	rjmp	.-2602   	; 0x416 <shiftleftledon>
		break;
 e40:	08 95       	ret
		
		case 4:
		shiftleftholdledon();
 e42:	0f cb       	rjmp	.-2530   	; 0x462 <shiftrightledon>
 e44:	08 95       	ret
		break;
 e46:	33 cb       	rjmp	.-2458   	; 0x4ae <shiftleftholdledon>
		
		case 5:
		shiftrightholdledon();
 e48:	08 95       	ret
 e4a:	56 cb       	rjmp	.-2388   	; 0x4f8 <shiftrightholdledon>
		break;
 e4c:	08 95       	ret
		
		case 6:
		f_off();
 e4e:	79 cb       	rjmp	.-2318   	; 0x542 <f_off>
 e50:	08 95       	ret
		break;
 e52:	a7 cb       	rjmp	.-2226   	; 0x5a2 <flower_on>
		
		case 7:
		flower_on();
 e54:	08 95       	ret

00000e56 <__udivmodsi4>:
 e56:	a1 e2       	ldi	r26, 0x21	; 33
 e58:	1a 2e       	mov	r1, r26
 e5a:	aa 1b       	sub	r26, r26
 e5c:	bb 1b       	sub	r27, r27
 e5e:	fd 01       	movw	r30, r26
 e60:	0d c0       	rjmp	.+26     	; 0xe7c <__udivmodsi4_ep>

00000e62 <__udivmodsi4_loop>:
 e62:	aa 1f       	adc	r26, r26
 e64:	bb 1f       	adc	r27, r27
 e66:	ee 1f       	adc	r30, r30
 e68:	ff 1f       	adc	r31, r31
 e6a:	a2 17       	cp	r26, r18
 e6c:	b3 07       	cpc	r27, r19
 e6e:	e4 07       	cpc	r30, r20
 e70:	f5 07       	cpc	r31, r21
 e72:	20 f0       	brcs	.+8      	; 0xe7c <__udivmodsi4_ep>
 e74:	a2 1b       	sub	r26, r18
 e76:	b3 0b       	sbc	r27, r19
 e78:	e4 0b       	sbc	r30, r20
 e7a:	f5 0b       	sbc	r31, r21

00000e7c <__udivmodsi4_ep>:
 e7c:	66 1f       	adc	r22, r22
 e7e:	77 1f       	adc	r23, r23
 e80:	88 1f       	adc	r24, r24
 e82:	99 1f       	adc	r25, r25
 e84:	1a 94       	dec	r1
 e86:	69 f7       	brne	.-38     	; 0xe62 <__udivmodsi4_loop>
 e88:	60 95       	com	r22
 e8a:	70 95       	com	r23
 e8c:	80 95       	com	r24
 e8e:	90 95       	com	r25
 e90:	9b 01       	movw	r18, r22
 e92:	ac 01       	movw	r20, r24
 e94:	bd 01       	movw	r22, r26
 e96:	cf 01       	movw	r24, r30
 e98:	08 95       	ret

00000e9a <__tablejump2__>:
 e9a:	ee 0f       	add	r30, r30
 e9c:	ff 1f       	adc	r31, r31
 e9e:	00 24       	eor	r0, r0
 ea0:	00 1c       	adc	r0, r0
 ea2:	0b be       	out	0x3b, r0	; 59
 ea4:	07 90       	elpm	r0, Z+
 ea6:	f6 91       	elpm	r31, Z
 ea8:	e0 2d       	mov	r30, r0
 eaa:	09 94       	ijmp

00000eac <__umulhisi3>:
 eac:	a2 9f       	mul	r26, r18
 eae:	b0 01       	movw	r22, r0
 eb0:	b3 9f       	mul	r27, r19
 eb2:	c0 01       	movw	r24, r0
 eb4:	a3 9f       	mul	r26, r19
 eb6:	70 0d       	add	r23, r0
 eb8:	81 1d       	adc	r24, r1
 eba:	11 24       	eor	r1, r1
 ebc:	91 1d       	adc	r25, r1
 ebe:	b2 9f       	mul	r27, r18
 ec0:	70 0d       	add	r23, r0
 ec2:	81 1d       	adc	r24, r1
 ec4:	11 24       	eor	r1, r1
 ec6:	91 1d       	adc	r25, r1
 ec8:	08 95       	ret

00000eca <strncmp>:
 eca:	fb 01       	movw	r30, r22
 ecc:	dc 01       	movw	r26, r24
 ece:	41 50       	subi	r20, 0x01	; 1
 ed0:	50 40       	sbci	r21, 0x00	; 0
 ed2:	30 f0       	brcs	.+12     	; 0xee0 <strncmp+0x16>
 ed4:	8d 91       	ld	r24, X+
 ed6:	01 90       	ld	r0, Z+
 ed8:	80 19       	sub	r24, r0
 eda:	19 f4       	brne	.+6      	; 0xee2 <strncmp+0x18>
 edc:	00 20       	and	r0, r0
 ede:	b9 f7       	brne	.-18     	; 0xece <strncmp+0x4>
 ee0:	88 1b       	sub	r24, r24
 ee2:	99 0b       	sbc	r25, r25
 ee4:	08 95       	ret

00000ee6 <puts>:
 ee6:	0f 93       	push	r16
 ee8:	1f 93       	push	r17
 eea:	cf 93       	push	r28
 eec:	df 93       	push	r29
 eee:	e0 91 75 02 	lds	r30, 0x0275	; 0x800275 <__iob+0x2>
 ef2:	f0 91 76 02 	lds	r31, 0x0276	; 0x800276 <__iob+0x3>
 ef6:	23 81       	ldd	r18, Z+3	; 0x03
 ef8:	21 ff       	sbrs	r18, 1
 efa:	1b c0       	rjmp	.+54     	; 0xf32 <puts+0x4c>
 efc:	8c 01       	movw	r16, r24
 efe:	d0 e0       	ldi	r29, 0x00	; 0
 f00:	c0 e0       	ldi	r28, 0x00	; 0
 f02:	f8 01       	movw	r30, r16
 f04:	81 91       	ld	r24, Z+
 f06:	8f 01       	movw	r16, r30
 f08:	60 91 75 02 	lds	r22, 0x0275	; 0x800275 <__iob+0x2>
 f0c:	70 91 76 02 	lds	r23, 0x0276	; 0x800276 <__iob+0x3>
 f10:	db 01       	movw	r26, r22
 f12:	18 96       	adiw	r26, 0x08	; 8
 f14:	ed 91       	ld	r30, X+
 f16:	fc 91       	ld	r31, X
 f18:	19 97       	sbiw	r26, 0x09	; 9
 f1a:	88 23       	and	r24, r24
 f1c:	31 f0       	breq	.+12     	; 0xf2a <puts+0x44>
 f1e:	09 95       	icall
 f20:	89 2b       	or	r24, r25
 f22:	79 f3       	breq	.-34     	; 0xf02 <puts+0x1c>
 f24:	df ef       	ldi	r29, 0xFF	; 255
 f26:	cf ef       	ldi	r28, 0xFF	; 255
 f28:	ec cf       	rjmp	.-40     	; 0xf02 <puts+0x1c>
 f2a:	8a e0       	ldi	r24, 0x0A	; 10
 f2c:	09 95       	icall
 f2e:	89 2b       	or	r24, r25
 f30:	19 f0       	breq	.+6      	; 0xf38 <puts+0x52>
 f32:	8f ef       	ldi	r24, 0xFF	; 255
 f34:	9f ef       	ldi	r25, 0xFF	; 255
 f36:	02 c0       	rjmp	.+4      	; 0xf3c <puts+0x56>
 f38:	8d 2f       	mov	r24, r29
 f3a:	9c 2f       	mov	r25, r28
 f3c:	df 91       	pop	r29
 f3e:	cf 91       	pop	r28
 f40:	1f 91       	pop	r17
 f42:	0f 91       	pop	r16
 f44:	08 95       	ret

00000f46 <_exit>:
 f46:	f8 94       	cli

00000f48 <__stop_program>:
 f48:	ff cf       	rjmp	.-2      	; 0xf48 <__stop_program>
